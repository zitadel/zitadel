// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/zitadel/zitadel/backend/v3/domain (interfaces: PasskeyRepository)
//
// Generated by this command:
//
//	mockgen -typed -package domainmock -destination ./mock/user_human_passkey.mock.go . PasskeyRepository
//

// Package domainmock is a generated GoMock package.
package domainmock

import (
	context "context"
	reflect "reflect"
	time "time"

	domain "github.com/zitadel/zitadel/backend/v3/domain"
	database "github.com/zitadel/zitadel/backend/v3/storage/database"
	gomock "go.uber.org/mock/gomock"
)

// MockPasskeyRepository is a mock of PasskeyRepository interface.
type MockPasskeyRepository struct {
	ctrl     *gomock.Controller
	recorder *MockPasskeyRepositoryMockRecorder
	isgomock struct{}
}

// MockPasskeyRepositoryMockRecorder is the mock recorder for MockPasskeyRepository.
type MockPasskeyRepositoryMockRecorder struct {
	mock *MockPasskeyRepository
}

// NewMockPasskeyRepository creates a new mock instance.
func NewMockPasskeyRepository(ctrl *gomock.Controller) *MockPasskeyRepository {
	mock := &MockPasskeyRepository{ctrl: ctrl}
	mock.recorder = &MockPasskeyRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPasskeyRepository) EXPECT() *MockPasskeyRepositoryMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockPasskeyRepository) Add(ctx context.Context, client database.QueryExecutor, passkey *domain.Passkey) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", ctx, client, passkey)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockPasskeyRepositoryMockRecorder) Add(ctx, client, passkey any) *MockPasskeyRepositoryAddCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockPasskeyRepository)(nil).Add), ctx, client, passkey)
	return &MockPasskeyRepositoryAddCall{Call: call}
}

// MockPasskeyRepositoryAddCall wrap *gomock.Call
type MockPasskeyRepositoryAddCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryAddCall) Return(arg0 error) *MockPasskeyRepositoryAddCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryAddCall) Do(f func(context.Context, database.QueryExecutor, *domain.Passkey) error) *MockPasskeyRepositoryAddCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryAddCall) DoAndReturn(f func(context.Context, database.QueryExecutor, *domain.Passkey) error) *MockPasskeyRepositoryAddCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockPasskeyRepository) Delete(ctx context.Context, client database.QueryExecutor, condition database.Condition) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, client, condition)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockPasskeyRepositoryMockRecorder) Delete(ctx, client, condition any) *MockPasskeyRepositoryDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPasskeyRepository)(nil).Delete), ctx, client, condition)
	return &MockPasskeyRepositoryDeleteCall{Call: call}
}

// MockPasskeyRepositoryDeleteCall wrap *gomock.Call
type MockPasskeyRepositoryDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryDeleteCall) Return(arg0 int64, arg1 error) *MockPasskeyRepositoryDeleteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryDeleteCall) Do(f func(context.Context, database.QueryExecutor, database.Condition) (int64, error)) *MockPasskeyRepositoryDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryDeleteCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition) (int64, error)) *MockPasskeyRepositoryDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockPasskeyRepository) Get(ctx context.Context, client database.QueryExecutor, condition database.Condition) (*domain.Passkey, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, client, condition)
	ret0, _ := ret[0].(*domain.Passkey)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockPasskeyRepositoryMockRecorder) Get(ctx, client, condition any) *MockPasskeyRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPasskeyRepository)(nil).Get), ctx, client, condition)
	return &MockPasskeyRepositoryGetCall{Call: call}
}

// MockPasskeyRepositoryGetCall wrap *gomock.Call
type MockPasskeyRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryGetCall) Return(arg0 *domain.Passkey, arg1 error) *MockPasskeyRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryGetCall) Do(f func(context.Context, database.QueryExecutor, database.Condition) (*domain.Passkey, error)) *MockPasskeyRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryGetCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition) (*domain.Passkey, error)) *MockPasskeyRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetInitializationVerification mocks base method.
func (m *MockPasskeyRepository) GetInitializationVerification(ctx context.Context, client database.QueryExecutor, condition database.Condition) (*domain.Verification, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInitializationVerification", ctx, client, condition)
	ret0, _ := ret[0].(*domain.Verification)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetInitializationVerification indicates an expected call of GetInitializationVerification.
func (mr *MockPasskeyRepositoryMockRecorder) GetInitializationVerification(ctx, client, condition any) *MockPasskeyRepositoryGetInitializationVerificationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInitializationVerification", reflect.TypeOf((*MockPasskeyRepository)(nil).GetInitializationVerification), ctx, client, condition)
	return &MockPasskeyRepositoryGetInitializationVerificationCall{Call: call}
}

// MockPasskeyRepositoryGetInitializationVerificationCall wrap *gomock.Call
type MockPasskeyRepositoryGetInitializationVerificationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryGetInitializationVerificationCall) Return(arg0 *domain.Verification, arg1 error) *MockPasskeyRepositoryGetInitializationVerificationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryGetInitializationVerificationCall) Do(f func(context.Context, database.QueryExecutor, database.Condition) (*domain.Verification, error)) *MockPasskeyRepositoryGetInitializationVerificationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryGetInitializationVerificationCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition) (*domain.Verification, error)) *MockPasskeyRepositoryGetInitializationVerificationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IncrementFailedInitializationAttempts mocks base method.
func (m *MockPasskeyRepository) IncrementFailedInitializationAttempts(ctx context.Context, client database.QueryExecutor, condition database.Condition) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IncrementFailedInitializationAttempts", ctx, client, condition)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IncrementFailedInitializationAttempts indicates an expected call of IncrementFailedInitializationAttempts.
func (mr *MockPasskeyRepositoryMockRecorder) IncrementFailedInitializationAttempts(ctx, client, condition any) *MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IncrementFailedInitializationAttempts", reflect.TypeOf((*MockPasskeyRepository)(nil).IncrementFailedInitializationAttempts), ctx, client, condition)
	return &MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall{Call: call}
}

// MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall wrap *gomock.Call
type MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall) Return(arg0 int64, arg1 error) *MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall) Do(f func(context.Context, database.QueryExecutor, database.Condition) (int64, error)) *MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition) (int64, error)) *MockPasskeyRepositoryIncrementFailedInitializationAttemptsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InstanceIDCondition mocks base method.
func (m *MockPasskeyRepository) InstanceIDCondition(instanceID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceIDCondition", instanceID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// InstanceIDCondition indicates an expected call of InstanceIDCondition.
func (mr *MockPasskeyRepositoryMockRecorder) InstanceIDCondition(instanceID any) *MockPasskeyRepositoryInstanceIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceIDCondition", reflect.TypeOf((*MockPasskeyRepository)(nil).InstanceIDCondition), instanceID)
	return &MockPasskeyRepositoryInstanceIDConditionCall{Call: call}
}

// MockPasskeyRepositoryInstanceIDConditionCall wrap *gomock.Call
type MockPasskeyRepositoryInstanceIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryInstanceIDConditionCall) Return(arg0 database.Condition) *MockPasskeyRepositoryInstanceIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryInstanceIDConditionCall) Do(f func(string) database.Condition) *MockPasskeyRepositoryInstanceIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryInstanceIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockPasskeyRepositoryInstanceIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *MockPasskeyRepository) List(ctx context.Context, client database.QueryExecutor, condition database.Condition, limit, offset int) ([]*domain.Passkey, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, client, condition, limit, offset)
	ret0, _ := ret[0].([]*domain.Passkey)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockPasskeyRepositoryMockRecorder) List(ctx, client, condition, limit, offset any) *MockPasskeyRepositoryListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockPasskeyRepository)(nil).List), ctx, client, condition, limit, offset)
	return &MockPasskeyRepositoryListCall{Call: call}
}

// MockPasskeyRepositoryListCall wrap *gomock.Call
type MockPasskeyRepositoryListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryListCall) Return(arg0 []*domain.Passkey, arg1 error) *MockPasskeyRepositoryListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryListCall) Do(f func(context.Context, database.QueryExecutor, database.Condition, int, int) ([]*domain.Passkey, error)) *MockPasskeyRepositoryListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryListCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition, int, int) ([]*domain.Passkey, error)) *MockPasskeyRepositoryListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrimaryKeyCondition mocks base method.
func (m *MockPasskeyRepository) PrimaryKeyCondition(instanceID, tokenID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrimaryKeyCondition", instanceID, tokenID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// PrimaryKeyCondition indicates an expected call of PrimaryKeyCondition.
func (mr *MockPasskeyRepositoryMockRecorder) PrimaryKeyCondition(instanceID, tokenID any) *MockPasskeyRepositoryPrimaryKeyConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrimaryKeyCondition", reflect.TypeOf((*MockPasskeyRepository)(nil).PrimaryKeyCondition), instanceID, tokenID)
	return &MockPasskeyRepositoryPrimaryKeyConditionCall{Call: call}
}

// MockPasskeyRepositoryPrimaryKeyConditionCall wrap *gomock.Call
type MockPasskeyRepositoryPrimaryKeyConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryPrimaryKeyConditionCall) Return(arg0 database.Condition) *MockPasskeyRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryPrimaryKeyConditionCall) Do(f func(string, string) database.Condition) *MockPasskeyRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryPrimaryKeyConditionCall) DoAndReturn(f func(string, string) database.Condition) *MockPasskeyRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetInitializationVerification mocks base method.
func (m *MockPasskeyRepository) SetInitializationVerification(ctx context.Context, client database.QueryExecutor, condition database.Condition, verification domain.VerificationType) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetInitializationVerification", ctx, client, condition, verification)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SetInitializationVerification indicates an expected call of SetInitializationVerification.
func (mr *MockPasskeyRepositoryMockRecorder) SetInitializationVerification(ctx, client, condition, verification any) *MockPasskeyRepositorySetInitializationVerificationCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetInitializationVerification", reflect.TypeOf((*MockPasskeyRepository)(nil).SetInitializationVerification), ctx, client, condition, verification)
	return &MockPasskeyRepositorySetInitializationVerificationCall{Call: call}
}

// MockPasskeyRepositorySetInitializationVerificationCall wrap *gomock.Call
type MockPasskeyRepositorySetInitializationVerificationCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositorySetInitializationVerificationCall) Return(arg0 int64, arg1 error) *MockPasskeyRepositorySetInitializationVerificationCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositorySetInitializationVerificationCall) Do(f func(context.Context, database.QueryExecutor, database.Condition, domain.VerificationType) (int64, error)) *MockPasskeyRepositorySetInitializationVerificationCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositorySetInitializationVerificationCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition, domain.VerificationType) (int64, error)) *MockPasskeyRepositorySetInitializationVerificationCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetSignCount mocks base method.
func (m *MockPasskeyRepository) SetSignCount(signCount uint32) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetSignCount", signCount)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetSignCount indicates an expected call of SetSignCount.
func (mr *MockPasskeyRepositoryMockRecorder) SetSignCount(signCount any) *MockPasskeyRepositorySetSignCountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSignCount", reflect.TypeOf((*MockPasskeyRepository)(nil).SetSignCount), signCount)
	return &MockPasskeyRepositorySetSignCountCall{Call: call}
}

// MockPasskeyRepositorySetSignCountCall wrap *gomock.Call
type MockPasskeyRepositorySetSignCountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositorySetSignCountCall) Return(arg0 database.Change) *MockPasskeyRepositorySetSignCountCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositorySetSignCountCall) Do(f func(uint32) database.Change) *MockPasskeyRepositorySetSignCountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositorySetSignCountCall) DoAndReturn(f func(uint32) database.Change) *MockPasskeyRepositorySetSignCountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockPasskeyRepository) SetState(state domain.PasskeyState) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetState", state)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetState indicates an expected call of SetState.
func (mr *MockPasskeyRepositoryMockRecorder) SetState(state any) *MockPasskeyRepositorySetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockPasskeyRepository)(nil).SetState), state)
	return &MockPasskeyRepositorySetStateCall{Call: call}
}

// MockPasskeyRepositorySetStateCall wrap *gomock.Call
type MockPasskeyRepositorySetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositorySetStateCall) Return(arg0 database.Change) *MockPasskeyRepositorySetStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositorySetStateCall) Do(f func(domain.PasskeyState) database.Change) *MockPasskeyRepositorySetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositorySetStateCall) DoAndReturn(f func(domain.PasskeyState) database.Change) *MockPasskeyRepositorySetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUpdatedAt mocks base method.
func (m *MockPasskeyRepository) SetUpdatedAt(updatedAt time.Time) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUpdatedAt", updatedAt)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetUpdatedAt indicates an expected call of SetUpdatedAt.
func (mr *MockPasskeyRepositoryMockRecorder) SetUpdatedAt(updatedAt any) *MockPasskeyRepositorySetUpdatedAtCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUpdatedAt", reflect.TypeOf((*MockPasskeyRepository)(nil).SetUpdatedAt), updatedAt)
	return &MockPasskeyRepositorySetUpdatedAtCall{Call: call}
}

// MockPasskeyRepositorySetUpdatedAtCall wrap *gomock.Call
type MockPasskeyRepositorySetUpdatedAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositorySetUpdatedAtCall) Return(arg0 database.Change) *MockPasskeyRepositorySetUpdatedAtCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositorySetUpdatedAtCall) Do(f func(time.Time) database.Change) *MockPasskeyRepositorySetUpdatedAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositorySetUpdatedAtCall) DoAndReturn(f func(time.Time) database.Change) *MockPasskeyRepositorySetUpdatedAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockPasskeyRepository) Update(ctx context.Context, client database.QueryExecutor, condition database.Condition, changes ...database.Change) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, client, condition}
	for _, a := range changes {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockPasskeyRepositoryMockRecorder) Update(ctx, client, condition any, changes ...any) *MockPasskeyRepositoryUpdateCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, client, condition}, changes...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockPasskeyRepository)(nil).Update), varargs...)
	return &MockPasskeyRepositoryUpdateCall{Call: call}
}

// MockPasskeyRepositoryUpdateCall wrap *gomock.Call
type MockPasskeyRepositoryUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryUpdateCall) Return(arg0 int64, arg1 error) *MockPasskeyRepositoryUpdateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryUpdateCall) Do(f func(context.Context, database.QueryExecutor, database.Condition, ...database.Change) (int64, error)) *MockPasskeyRepositoryUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryUpdateCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition, ...database.Change) (int64, error)) *MockPasskeyRepositoryUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UserIDCondition mocks base method.
func (m *MockPasskeyRepository) UserIDCondition(userID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserIDCondition", userID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// UserIDCondition indicates an expected call of UserIDCondition.
func (mr *MockPasskeyRepositoryMockRecorder) UserIDCondition(userID any) *MockPasskeyRepositoryUserIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserIDCondition", reflect.TypeOf((*MockPasskeyRepository)(nil).UserIDCondition), userID)
	return &MockPasskeyRepositoryUserIDConditionCall{Call: call}
}

// MockPasskeyRepositoryUserIDConditionCall wrap *gomock.Call
type MockPasskeyRepositoryUserIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPasskeyRepositoryUserIDConditionCall) Return(arg0 database.Condition) *MockPasskeyRepositoryUserIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPasskeyRepositoryUserIDConditionCall) Do(f func(string) database.Condition) *MockPasskeyRepositoryUserIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPasskeyRepositoryUserIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockPasskeyRepositoryUserIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
