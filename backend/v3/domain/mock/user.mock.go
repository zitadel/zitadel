// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/zitadel/zitadel/backend/v3/domain (interfaces: UserRepository)
//
// Generated by this command:
//
//	mockgen -typed -package domainmock -destination ./mock/user.mock.go . UserRepository
//

// Package domainmock is a generated GoMock package.
package domainmock

import (
	context "context"
	reflect "reflect"
	time "time"

	domain "github.com/zitadel/zitadel/backend/v3/domain"
	database "github.com/zitadel/zitadel/backend/v3/storage/database"
	gomock "go.uber.org/mock/gomock"
)

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
	ctrl     *gomock.Controller
	recorder *MockUserRepositoryMockRecorder
	isgomock struct{}
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
	mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository {
	mock := &MockUserRepository{ctrl: ctrl}
	mock.recorder = &MockUserRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder {
	return m.recorder
}

// AddMetadata mocks base method.
func (m *MockUserRepository) AddMetadata(metadata ...*domain.Metadata) database.Change {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range metadata {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddMetadata", varargs...)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// AddMetadata indicates an expected call of AddMetadata.
func (mr *MockUserRepositoryMockRecorder) AddMetadata(metadata ...any) *MockUserRepositoryAddMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddMetadata", reflect.TypeOf((*MockUserRepository)(nil).AddMetadata), metadata...)
	return &MockUserRepositoryAddMetadataCall{Call: call}
}

// MockUserRepositoryAddMetadataCall wrap *gomock.Call
type MockUserRepositoryAddMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryAddMetadataCall) Return(arg0 database.Change) *MockUserRepositoryAddMetadataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryAddMetadataCall) Do(f func(...*domain.Metadata) database.Change) *MockUserRepositoryAddMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryAddMetadataCall) DoAndReturn(f func(...*domain.Metadata) database.Change) *MockUserRepositoryAddMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Create mocks base method.
func (m *MockUserRepository) Create(ctx context.Context, client database.QueryExecutor, user *domain.User) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, client, user)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockUserRepositoryMockRecorder) Create(ctx, client, user any) *MockUserRepositoryCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserRepository)(nil).Create), ctx, client, user)
	return &MockUserRepositoryCreateCall{Call: call}
}

// MockUserRepositoryCreateCall wrap *gomock.Call
type MockUserRepositoryCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryCreateCall) Return(arg0 error) *MockUserRepositoryCreateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryCreateCall) Do(f func(context.Context, database.QueryExecutor, *domain.User) error) *MockUserRepositoryCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryCreateCall) DoAndReturn(f func(context.Context, database.QueryExecutor, *domain.User) error) *MockUserRepositoryCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreatedAtColumn mocks base method.
func (m *MockUserRepository) CreatedAtColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreatedAtColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// CreatedAtColumn indicates an expected call of CreatedAtColumn.
func (mr *MockUserRepositoryMockRecorder) CreatedAtColumn() *MockUserRepositoryCreatedAtColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatedAtColumn", reflect.TypeOf((*MockUserRepository)(nil).CreatedAtColumn))
	return &MockUserRepositoryCreatedAtColumnCall{Call: call}
}

// MockUserRepositoryCreatedAtColumnCall wrap *gomock.Call
type MockUserRepositoryCreatedAtColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryCreatedAtColumnCall) Return(arg0 database.Column) *MockUserRepositoryCreatedAtColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryCreatedAtColumnCall) Do(f func() database.Column) *MockUserRepositoryCreatedAtColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryCreatedAtColumnCall) DoAndReturn(f func() database.Column) *MockUserRepositoryCreatedAtColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockUserRepository) Delete(ctx context.Context, client database.QueryExecutor, condition database.Condition) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, client, condition)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockUserRepositoryMockRecorder) Delete(ctx, client, condition any) *MockUserRepositoryDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserRepository)(nil).Delete), ctx, client, condition)
	return &MockUserRepositoryDeleteCall{Call: call}
}

// MockUserRepositoryDeleteCall wrap *gomock.Call
type MockUserRepositoryDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryDeleteCall) Return(arg0 int64, arg1 error) *MockUserRepositoryDeleteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryDeleteCall) Do(f func(context.Context, database.QueryExecutor, database.Condition) (int64, error)) *MockUserRepositoryDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryDeleteCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition) (int64, error)) *MockUserRepositoryDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExistsMetadata mocks base method.
func (m *MockUserRepository) ExistsMetadata(condition database.Condition) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistsMetadata", condition)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// ExistsMetadata indicates an expected call of ExistsMetadata.
func (mr *MockUserRepositoryMockRecorder) ExistsMetadata(condition any) *MockUserRepositoryExistsMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistsMetadata", reflect.TypeOf((*MockUserRepository)(nil).ExistsMetadata), condition)
	return &MockUserRepositoryExistsMetadataCall{Call: call}
}

// MockUserRepositoryExistsMetadataCall wrap *gomock.Call
type MockUserRepositoryExistsMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryExistsMetadataCall) Return(arg0 database.Condition) *MockUserRepositoryExistsMetadataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryExistsMetadataCall) Do(f func(database.Condition) database.Condition) *MockUserRepositoryExistsMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryExistsMetadataCall) DoAndReturn(f func(database.Condition) database.Condition) *MockUserRepositoryExistsMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockUserRepository) Get(ctx context.Context, client database.QueryExecutor, opts ...database.QueryOption) (*domain.User, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, client}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(*domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockUserRepositoryMockRecorder) Get(ctx, client any, opts ...any) *MockUserRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, client}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockUserRepository)(nil).Get), varargs...)
	return &MockUserRepositoryGetCall{Call: call}
}

// MockUserRepositoryGetCall wrap *gomock.Call
type MockUserRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryGetCall) Return(arg0 *domain.User, arg1 error) *MockUserRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryGetCall) Do(f func(context.Context, database.QueryExecutor, ...database.QueryOption) (*domain.User, error)) *MockUserRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryGetCall) DoAndReturn(f func(context.Context, database.QueryExecutor, ...database.QueryOption) (*domain.User, error)) *MockUserRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Human mocks base method.
func (m *MockUserRepository) Human() domain.HumanUserRepository {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Human")
	ret0, _ := ret[0].(domain.HumanUserRepository)
	return ret0
}

// Human indicates an expected call of Human.
func (mr *MockUserRepositoryMockRecorder) Human() *MockUserRepositoryHumanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Human", reflect.TypeOf((*MockUserRepository)(nil).Human))
	return &MockUserRepositoryHumanCall{Call: call}
}

// MockUserRepositoryHumanCall wrap *gomock.Call
type MockUserRepositoryHumanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryHumanCall) Return(arg0 domain.HumanUserRepository) *MockUserRepositoryHumanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryHumanCall) Do(f func() domain.HumanUserRepository) *MockUserRepositoryHumanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryHumanCall) DoAndReturn(f func() domain.HumanUserRepository) *MockUserRepositoryHumanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IDColumn mocks base method.
func (m *MockUserRepository) IDColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IDColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// IDColumn indicates an expected call of IDColumn.
func (mr *MockUserRepositoryMockRecorder) IDColumn() *MockUserRepositoryIDColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IDColumn", reflect.TypeOf((*MockUserRepository)(nil).IDColumn))
	return &MockUserRepositoryIDColumnCall{Call: call}
}

// MockUserRepositoryIDColumnCall wrap *gomock.Call
type MockUserRepositoryIDColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryIDColumnCall) Return(arg0 database.Column) *MockUserRepositoryIDColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryIDColumnCall) Do(f func() database.Column) *MockUserRepositoryIDColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryIDColumnCall) DoAndReturn(f func() database.Column) *MockUserRepositoryIDColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IDCondition mocks base method.
func (m *MockUserRepository) IDCondition(userID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IDCondition", userID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// IDCondition indicates an expected call of IDCondition.
func (mr *MockUserRepositoryMockRecorder) IDCondition(userID any) *MockUserRepositoryIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IDCondition", reflect.TypeOf((*MockUserRepository)(nil).IDCondition), userID)
	return &MockUserRepositoryIDConditionCall{Call: call}
}

// MockUserRepositoryIDConditionCall wrap *gomock.Call
type MockUserRepositoryIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryIDConditionCall) Return(arg0 database.Condition) *MockUserRepositoryIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryIDConditionCall) Do(f func(string) database.Condition) *MockUserRepositoryIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockUserRepositoryIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InstanceIDColumn mocks base method.
func (m *MockUserRepository) InstanceIDColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceIDColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// InstanceIDColumn indicates an expected call of InstanceIDColumn.
func (mr *MockUserRepositoryMockRecorder) InstanceIDColumn() *MockUserRepositoryInstanceIDColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceIDColumn", reflect.TypeOf((*MockUserRepository)(nil).InstanceIDColumn))
	return &MockUserRepositoryInstanceIDColumnCall{Call: call}
}

// MockUserRepositoryInstanceIDColumnCall wrap *gomock.Call
type MockUserRepositoryInstanceIDColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryInstanceIDColumnCall) Return(arg0 database.Column) *MockUserRepositoryInstanceIDColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryInstanceIDColumnCall) Do(f func() database.Column) *MockUserRepositoryInstanceIDColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryInstanceIDColumnCall) DoAndReturn(f func() database.Column) *MockUserRepositoryInstanceIDColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InstanceIDCondition mocks base method.
func (m *MockUserRepository) InstanceIDCondition(instanceID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceIDCondition", instanceID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// InstanceIDCondition indicates an expected call of InstanceIDCondition.
func (mr *MockUserRepositoryMockRecorder) InstanceIDCondition(instanceID any) *MockUserRepositoryInstanceIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceIDCondition", reflect.TypeOf((*MockUserRepository)(nil).InstanceIDCondition), instanceID)
	return &MockUserRepositoryInstanceIDConditionCall{Call: call}
}

// MockUserRepositoryInstanceIDConditionCall wrap *gomock.Call
type MockUserRepositoryInstanceIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryInstanceIDConditionCall) Return(arg0 database.Condition) *MockUserRepositoryInstanceIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryInstanceIDConditionCall) Do(f func(string) database.Condition) *MockUserRepositoryInstanceIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryInstanceIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockUserRepositoryInstanceIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *MockUserRepository) List(ctx context.Context, client database.QueryExecutor, opts ...database.QueryOption) ([]*domain.User, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, client}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "List", varargs...)
	ret0, _ := ret[0].([]*domain.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockUserRepositoryMockRecorder) List(ctx, client any, opts ...any) *MockUserRepositoryListCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, client}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockUserRepository)(nil).List), varargs...)
	return &MockUserRepositoryListCall{Call: call}
}

// MockUserRepositoryListCall wrap *gomock.Call
type MockUserRepositoryListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryListCall) Return(arg0 []*domain.User, arg1 error) *MockUserRepositoryListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryListCall) Do(f func(context.Context, database.QueryExecutor, ...database.QueryOption) ([]*domain.User, error)) *MockUserRepositoryListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryListCall) DoAndReturn(f func(context.Context, database.QueryExecutor, ...database.QueryOption) ([]*domain.User, error)) *MockUserRepositoryListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LoginNameCondition mocks base method.
func (m *MockUserRepository) LoginNameCondition(op database.TextOperation, loginName string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoginNameCondition", op, loginName)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// LoginNameCondition indicates an expected call of LoginNameCondition.
func (mr *MockUserRepositoryMockRecorder) LoginNameCondition(op, loginName any) *MockUserRepositoryLoginNameConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoginNameCondition", reflect.TypeOf((*MockUserRepository)(nil).LoginNameCondition), op, loginName)
	return &MockUserRepositoryLoginNameConditionCall{Call: call}
}

// MockUserRepositoryLoginNameConditionCall wrap *gomock.Call
type MockUserRepositoryLoginNameConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryLoginNameConditionCall) Return(arg0 database.Condition) *MockUserRepositoryLoginNameConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryLoginNameConditionCall) Do(f func(database.TextOperation, string) database.Condition) *MockUserRepositoryLoginNameConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryLoginNameConditionCall) DoAndReturn(f func(database.TextOperation, string) database.Condition) *MockUserRepositoryLoginNameConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Machine mocks base method.
func (m *MockUserRepository) Machine() domain.MachineUserRepository {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Machine")
	ret0, _ := ret[0].(domain.MachineUserRepository)
	return ret0
}

// Machine indicates an expected call of Machine.
func (mr *MockUserRepositoryMockRecorder) Machine() *MockUserRepositoryMachineCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Machine", reflect.TypeOf((*MockUserRepository)(nil).Machine))
	return &MockUserRepositoryMachineCall{Call: call}
}

// MockUserRepositoryMachineCall wrap *gomock.Call
type MockUserRepositoryMachineCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryMachineCall) Return(arg0 domain.MachineUserRepository) *MockUserRepositoryMachineCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryMachineCall) Do(f func() domain.MachineUserRepository) *MockUserRepositoryMachineCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryMachineCall) DoAndReturn(f func() domain.MachineUserRepository) *MockUserRepositoryMachineCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MetadataConditions mocks base method.
func (m *MockUserRepository) MetadataConditions() domain.UserMetadataConditions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MetadataConditions")
	ret0, _ := ret[0].(domain.UserMetadataConditions)
	return ret0
}

// MetadataConditions indicates an expected call of MetadataConditions.
func (mr *MockUserRepositoryMockRecorder) MetadataConditions() *MockUserRepositoryMetadataConditionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetadataConditions", reflect.TypeOf((*MockUserRepository)(nil).MetadataConditions))
	return &MockUserRepositoryMetadataConditionsCall{Call: call}
}

// MockUserRepositoryMetadataConditionsCall wrap *gomock.Call
type MockUserRepositoryMetadataConditionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryMetadataConditionsCall) Return(arg0 domain.UserMetadataConditions) *MockUserRepositoryMetadataConditionsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryMetadataConditionsCall) Do(f func() domain.UserMetadataConditions) *MockUserRepositoryMetadataConditionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryMetadataConditionsCall) DoAndReturn(f func() domain.UserMetadataConditions) *MockUserRepositoryMetadataConditionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OrganizationIDCondition mocks base method.
func (m *MockUserRepository) OrganizationIDCondition(orgID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OrganizationIDCondition", orgID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// OrganizationIDCondition indicates an expected call of OrganizationIDCondition.
func (mr *MockUserRepositoryMockRecorder) OrganizationIDCondition(orgID any) *MockUserRepositoryOrganizationIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OrganizationIDCondition", reflect.TypeOf((*MockUserRepository)(nil).OrganizationIDCondition), orgID)
	return &MockUserRepositoryOrganizationIDConditionCall{Call: call}
}

// MockUserRepositoryOrganizationIDConditionCall wrap *gomock.Call
type MockUserRepositoryOrganizationIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryOrganizationIDConditionCall) Return(arg0 database.Condition) *MockUserRepositoryOrganizationIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryOrganizationIDConditionCall) Do(f func(string) database.Condition) *MockUserRepositoryOrganizationIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryOrganizationIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockUserRepositoryOrganizationIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrimaryKeyColumns mocks base method.
func (m *MockUserRepository) PrimaryKeyColumns() []database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrimaryKeyColumns")
	ret0, _ := ret[0].([]database.Column)
	return ret0
}

// PrimaryKeyColumns indicates an expected call of PrimaryKeyColumns.
func (mr *MockUserRepositoryMockRecorder) PrimaryKeyColumns() *MockUserRepositoryPrimaryKeyColumnsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrimaryKeyColumns", reflect.TypeOf((*MockUserRepository)(nil).PrimaryKeyColumns))
	return &MockUserRepositoryPrimaryKeyColumnsCall{Call: call}
}

// MockUserRepositoryPrimaryKeyColumnsCall wrap *gomock.Call
type MockUserRepositoryPrimaryKeyColumnsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryPrimaryKeyColumnsCall) Return(arg0 []database.Column) *MockUserRepositoryPrimaryKeyColumnsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryPrimaryKeyColumnsCall) Do(f func() []database.Column) *MockUserRepositoryPrimaryKeyColumnsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryPrimaryKeyColumnsCall) DoAndReturn(f func() []database.Column) *MockUserRepositoryPrimaryKeyColumnsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrimaryKeyCondition mocks base method.
func (m *MockUserRepository) PrimaryKeyCondition(instanceID, userID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrimaryKeyCondition", instanceID, userID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// PrimaryKeyCondition indicates an expected call of PrimaryKeyCondition.
func (mr *MockUserRepositoryMockRecorder) PrimaryKeyCondition(instanceID, userID any) *MockUserRepositoryPrimaryKeyConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrimaryKeyCondition", reflect.TypeOf((*MockUserRepository)(nil).PrimaryKeyCondition), instanceID, userID)
	return &MockUserRepositoryPrimaryKeyConditionCall{Call: call}
}

// MockUserRepositoryPrimaryKeyConditionCall wrap *gomock.Call
type MockUserRepositoryPrimaryKeyConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryPrimaryKeyConditionCall) Return(arg0 database.Condition) *MockUserRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryPrimaryKeyConditionCall) Do(f func(string, string) database.Condition) *MockUserRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryPrimaryKeyConditionCall) DoAndReturn(f func(string, string) database.Condition) *MockUserRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveMetadata mocks base method.
func (m *MockUserRepository) RemoveMetadata(condition database.Condition) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveMetadata", condition)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// RemoveMetadata indicates an expected call of RemoveMetadata.
func (mr *MockUserRepositoryMockRecorder) RemoveMetadata(condition any) *MockUserRepositoryRemoveMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveMetadata", reflect.TypeOf((*MockUserRepository)(nil).RemoveMetadata), condition)
	return &MockUserRepositoryRemoveMetadataCall{Call: call}
}

// MockUserRepositoryRemoveMetadataCall wrap *gomock.Call
type MockUserRepositoryRemoveMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryRemoveMetadataCall) Return(arg0 database.Change) *MockUserRepositoryRemoveMetadataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryRemoveMetadataCall) Do(f func(database.Condition) database.Change) *MockUserRepositoryRemoveMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryRemoveMetadataCall) DoAndReturn(f func(database.Condition) database.Change) *MockUserRepositoryRemoveMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockUserRepository) SetState(state domain.UserState) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetState", state)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetState indicates an expected call of SetState.
func (mr *MockUserRepositoryMockRecorder) SetState(state any) *MockUserRepositorySetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockUserRepository)(nil).SetState), state)
	return &MockUserRepositorySetStateCall{Call: call}
}

// MockUserRepositorySetStateCall wrap *gomock.Call
type MockUserRepositorySetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositorySetStateCall) Return(arg0 database.Change) *MockUserRepositorySetStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositorySetStateCall) Do(f func(domain.UserState) database.Change) *MockUserRepositorySetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositorySetStateCall) DoAndReturn(f func(domain.UserState) database.Change) *MockUserRepositorySetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUpdatedAt mocks base method.
func (m *MockUserRepository) SetUpdatedAt(updatedAt time.Time) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUpdatedAt", updatedAt)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetUpdatedAt indicates an expected call of SetUpdatedAt.
func (mr *MockUserRepositoryMockRecorder) SetUpdatedAt(updatedAt any) *MockUserRepositorySetUpdatedAtCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUpdatedAt", reflect.TypeOf((*MockUserRepository)(nil).SetUpdatedAt), updatedAt)
	return &MockUserRepositorySetUpdatedAtCall{Call: call}
}

// MockUserRepositorySetUpdatedAtCall wrap *gomock.Call
type MockUserRepositorySetUpdatedAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositorySetUpdatedAtCall) Return(arg0 database.Change) *MockUserRepositorySetUpdatedAtCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositorySetUpdatedAtCall) Do(f func(time.Time) database.Change) *MockUserRepositorySetUpdatedAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositorySetUpdatedAtCall) DoAndReturn(f func(time.Time) database.Change) *MockUserRepositorySetUpdatedAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUsername mocks base method.
func (m *MockUserRepository) SetUsername(username string) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUsername", username)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetUsername indicates an expected call of SetUsername.
func (mr *MockUserRepositoryMockRecorder) SetUsername(username any) *MockUserRepositorySetUsernameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUsername", reflect.TypeOf((*MockUserRepository)(nil).SetUsername), username)
	return &MockUserRepositorySetUsernameCall{Call: call}
}

// MockUserRepositorySetUsernameCall wrap *gomock.Call
type MockUserRepositorySetUsernameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositorySetUsernameCall) Return(arg0 database.Change) *MockUserRepositorySetUsernameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositorySetUsernameCall) Do(f func(string) database.Change) *MockUserRepositorySetUsernameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositorySetUsernameCall) DoAndReturn(f func(string) database.Change) *MockUserRepositorySetUsernameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StateColumn mocks base method.
func (m *MockUserRepository) StateColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StateColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// StateColumn indicates an expected call of StateColumn.
func (mr *MockUserRepositoryMockRecorder) StateColumn() *MockUserRepositoryStateColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StateColumn", reflect.TypeOf((*MockUserRepository)(nil).StateColumn))
	return &MockUserRepositoryStateColumnCall{Call: call}
}

// MockUserRepositoryStateColumnCall wrap *gomock.Call
type MockUserRepositoryStateColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryStateColumnCall) Return(arg0 database.Column) *MockUserRepositoryStateColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryStateColumnCall) Do(f func() database.Column) *MockUserRepositoryStateColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryStateColumnCall) DoAndReturn(f func() database.Column) *MockUserRepositoryStateColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StateCondition mocks base method.
func (m *MockUserRepository) StateCondition(state domain.UserState) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StateCondition", state)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// StateCondition indicates an expected call of StateCondition.
func (mr *MockUserRepositoryMockRecorder) StateCondition(state any) *MockUserRepositoryStateConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StateCondition", reflect.TypeOf((*MockUserRepository)(nil).StateCondition), state)
	return &MockUserRepositoryStateConditionCall{Call: call}
}

// MockUserRepositoryStateConditionCall wrap *gomock.Call
type MockUserRepositoryStateConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryStateConditionCall) Return(arg0 database.Condition) *MockUserRepositoryStateConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryStateConditionCall) Do(f func(domain.UserState) database.Condition) *MockUserRepositoryStateConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryStateConditionCall) DoAndReturn(f func(domain.UserState) database.Condition) *MockUserRepositoryStateConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TypeColumn mocks base method.
func (m *MockUserRepository) TypeColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TypeColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// TypeColumn indicates an expected call of TypeColumn.
func (mr *MockUserRepositoryMockRecorder) TypeColumn() *MockUserRepositoryTypeColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TypeColumn", reflect.TypeOf((*MockUserRepository)(nil).TypeColumn))
	return &MockUserRepositoryTypeColumnCall{Call: call}
}

// MockUserRepositoryTypeColumnCall wrap *gomock.Call
type MockUserRepositoryTypeColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryTypeColumnCall) Return(arg0 database.Column) *MockUserRepositoryTypeColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryTypeColumnCall) Do(f func() database.Column) *MockUserRepositoryTypeColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryTypeColumnCall) DoAndReturn(f func() database.Column) *MockUserRepositoryTypeColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TypeCondition mocks base method.
func (m *MockUserRepository) TypeCondition(userType domain.UserType) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TypeCondition", userType)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// TypeCondition indicates an expected call of TypeCondition.
func (mr *MockUserRepositoryMockRecorder) TypeCondition(userType any) *MockUserRepositoryTypeConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TypeCondition", reflect.TypeOf((*MockUserRepository)(nil).TypeCondition), userType)
	return &MockUserRepositoryTypeConditionCall{Call: call}
}

// MockUserRepositoryTypeConditionCall wrap *gomock.Call
type MockUserRepositoryTypeConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryTypeConditionCall) Return(arg0 database.Condition) *MockUserRepositoryTypeConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryTypeConditionCall) Do(f func(domain.UserType) database.Condition) *MockUserRepositoryTypeConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryTypeConditionCall) DoAndReturn(f func(domain.UserType) database.Condition) *MockUserRepositoryTypeConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockUserRepository) Update(ctx context.Context, client database.QueryExecutor, condition database.Condition, changes ...database.Change) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, client, condition}
	for _, a := range changes {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockUserRepositoryMockRecorder) Update(ctx, client, condition any, changes ...any) *MockUserRepositoryUpdateCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, client, condition}, changes...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserRepository)(nil).Update), varargs...)
	return &MockUserRepositoryUpdateCall{Call: call}
}

// MockUserRepositoryUpdateCall wrap *gomock.Call
type MockUserRepositoryUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryUpdateCall) Return(arg0 int64, arg1 error) *MockUserRepositoryUpdateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryUpdateCall) Do(f func(context.Context, database.QueryExecutor, database.Condition, ...database.Change) (int64, error)) *MockUserRepositoryUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryUpdateCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition, ...database.Change) (int64, error)) *MockUserRepositoryUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UsernameColumn mocks base method.
func (m *MockUserRepository) UsernameColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UsernameColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// UsernameColumn indicates an expected call of UsernameColumn.
func (mr *MockUserRepositoryMockRecorder) UsernameColumn() *MockUserRepositoryUsernameColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsernameColumn", reflect.TypeOf((*MockUserRepository)(nil).UsernameColumn))
	return &MockUserRepositoryUsernameColumnCall{Call: call}
}

// MockUserRepositoryUsernameColumnCall wrap *gomock.Call
type MockUserRepositoryUsernameColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryUsernameColumnCall) Return(arg0 database.Column) *MockUserRepositoryUsernameColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryUsernameColumnCall) Do(f func() database.Column) *MockUserRepositoryUsernameColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryUsernameColumnCall) DoAndReturn(f func() database.Column) *MockUserRepositoryUsernameColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UsernameCondition mocks base method.
func (m *MockUserRepository) UsernameCondition(op database.TextOperation, username string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UsernameCondition", op, username)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// UsernameCondition indicates an expected call of UsernameCondition.
func (mr *MockUserRepositoryMockRecorder) UsernameCondition(op, username any) *MockUserRepositoryUsernameConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsernameCondition", reflect.TypeOf((*MockUserRepository)(nil).UsernameCondition), op, username)
	return &MockUserRepositoryUsernameConditionCall{Call: call}
}

// MockUserRepositoryUsernameConditionCall wrap *gomock.Call
type MockUserRepositoryUsernameConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockUserRepositoryUsernameConditionCall) Return(arg0 database.Condition) *MockUserRepositoryUsernameConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockUserRepositoryUsernameConditionCall) Do(f func(database.TextOperation, string) database.Condition) *MockUserRepositoryUsernameConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockUserRepositoryUsernameConditionCall) DoAndReturn(f func(database.TextOperation, string) database.Condition) *MockUserRepositoryUsernameConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
