// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/zitadel/zitadel/backend/v3/domain (interfaces: PersonalAccessTokenRepository)
//
// Generated by this command:
//
//	mockgen -typed -package domainmock -destination ./mock/personal_access_token.mock.go . PersonalAccessTokenRepository
//

// Package domainmock is a generated GoMock package.
package domainmock

import (
	context "context"
	reflect "reflect"

	domain "github.com/zitadel/zitadel/backend/v3/domain"
	database "github.com/zitadel/zitadel/backend/v3/storage/database"
	gomock "go.uber.org/mock/gomock"
)

// MockPersonalAccessTokenRepository is a mock of PersonalAccessTokenRepository interface.
type MockPersonalAccessTokenRepository struct {
	ctrl     *gomock.Controller
	recorder *MockPersonalAccessTokenRepositoryMockRecorder
	isgomock struct{}
}

// MockPersonalAccessTokenRepositoryMockRecorder is the mock recorder for MockPersonalAccessTokenRepository.
type MockPersonalAccessTokenRepositoryMockRecorder struct {
	mock *MockPersonalAccessTokenRepository
}

// NewMockPersonalAccessTokenRepository creates a new mock instance.
func NewMockPersonalAccessTokenRepository(ctrl *gomock.Controller) *MockPersonalAccessTokenRepository {
	mock := &MockPersonalAccessTokenRepository{ctrl: ctrl}
	mock.recorder = &MockPersonalAccessTokenRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPersonalAccessTokenRepository) EXPECT() *MockPersonalAccessTokenRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockPersonalAccessTokenRepository) Create(ctx context.Context, client database.QueryExecutor, pat *domain.PersonalAccessToken) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, client, pat)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockPersonalAccessTokenRepositoryMockRecorder) Create(ctx, client, pat any) *MockPersonalAccessTokenRepositoryCreateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPersonalAccessTokenRepository)(nil).Create), ctx, client, pat)
	return &MockPersonalAccessTokenRepositoryCreateCall{Call: call}
}

// MockPersonalAccessTokenRepositoryCreateCall wrap *gomock.Call
type MockPersonalAccessTokenRepositoryCreateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPersonalAccessTokenRepositoryCreateCall) Return(arg0 error) *MockPersonalAccessTokenRepositoryCreateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPersonalAccessTokenRepositoryCreateCall) Do(f func(context.Context, database.QueryExecutor, *domain.PersonalAccessToken) error) *MockPersonalAccessTokenRepositoryCreateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPersonalAccessTokenRepositoryCreateCall) DoAndReturn(f func(context.Context, database.QueryExecutor, *domain.PersonalAccessToken) error) *MockPersonalAccessTokenRepositoryCreateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Delete mocks base method.
func (m *MockPersonalAccessTokenRepository) Delete(ctx context.Context, client database.QueryExecutor, condition database.Condition) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, client, condition)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete.
func (mr *MockPersonalAccessTokenRepositoryMockRecorder) Delete(ctx, client, condition any) *MockPersonalAccessTokenRepositoryDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPersonalAccessTokenRepository)(nil).Delete), ctx, client, condition)
	return &MockPersonalAccessTokenRepositoryDeleteCall{Call: call}
}

// MockPersonalAccessTokenRepositoryDeleteCall wrap *gomock.Call
type MockPersonalAccessTokenRepositoryDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPersonalAccessTokenRepositoryDeleteCall) Return(arg0 int64, arg1 error) *MockPersonalAccessTokenRepositoryDeleteCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPersonalAccessTokenRepositoryDeleteCall) Do(f func(context.Context, database.QueryExecutor, database.Condition) (int64, error)) *MockPersonalAccessTokenRepositoryDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPersonalAccessTokenRepositoryDeleteCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition) (int64, error)) *MockPersonalAccessTokenRepositoryDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockPersonalAccessTokenRepository) Get(ctx context.Context, client database.QueryExecutor, opts ...database.QueryOpts) (*domain.PersonalAccessToken, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, client}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].(*domain.PersonalAccessToken)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockPersonalAccessTokenRepositoryMockRecorder) Get(ctx, client any, opts ...any) *MockPersonalAccessTokenRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, client}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPersonalAccessTokenRepository)(nil).Get), varargs...)
	return &MockPersonalAccessTokenRepositoryGetCall{Call: call}
}

// MockPersonalAccessTokenRepositoryGetCall wrap *gomock.Call
type MockPersonalAccessTokenRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPersonalAccessTokenRepositoryGetCall) Return(arg0 *domain.PersonalAccessToken, arg1 error) *MockPersonalAccessTokenRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPersonalAccessTokenRepositoryGetCall) Do(f func(context.Context, database.QueryExecutor, ...database.QueryOpts) (*domain.PersonalAccessToken, error)) *MockPersonalAccessTokenRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPersonalAccessTokenRepositoryGetCall) DoAndReturn(f func(context.Context, database.QueryExecutor, ...database.QueryOpts) (*domain.PersonalAccessToken, error)) *MockPersonalAccessTokenRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InstanceIDCondition mocks base method.
func (m *MockPersonalAccessTokenRepository) InstanceIDCondition(instanceID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceIDCondition", instanceID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// InstanceIDCondition indicates an expected call of InstanceIDCondition.
func (mr *MockPersonalAccessTokenRepositoryMockRecorder) InstanceIDCondition(instanceID any) *MockPersonalAccessTokenRepositoryInstanceIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceIDCondition", reflect.TypeOf((*MockPersonalAccessTokenRepository)(nil).InstanceIDCondition), instanceID)
	return &MockPersonalAccessTokenRepositoryInstanceIDConditionCall{Call: call}
}

// MockPersonalAccessTokenRepositoryInstanceIDConditionCall wrap *gomock.Call
type MockPersonalAccessTokenRepositoryInstanceIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPersonalAccessTokenRepositoryInstanceIDConditionCall) Return(arg0 database.Condition) *MockPersonalAccessTokenRepositoryInstanceIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPersonalAccessTokenRepositoryInstanceIDConditionCall) Do(f func(string) database.Condition) *MockPersonalAccessTokenRepositoryInstanceIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPersonalAccessTokenRepositoryInstanceIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockPersonalAccessTokenRepositoryInstanceIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *MockPersonalAccessTokenRepository) List(ctx context.Context, client database.QueryExecutor, opts ...database.QueryOpts) ([]*domain.PersonalAccessToken, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, client}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "List", varargs...)
	ret0, _ := ret[0].([]*domain.PersonalAccessToken)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockPersonalAccessTokenRepositoryMockRecorder) List(ctx, client any, opts ...any) *MockPersonalAccessTokenRepositoryListCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, client}, opts...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockPersonalAccessTokenRepository)(nil).List), varargs...)
	return &MockPersonalAccessTokenRepositoryListCall{Call: call}
}

// MockPersonalAccessTokenRepositoryListCall wrap *gomock.Call
type MockPersonalAccessTokenRepositoryListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPersonalAccessTokenRepositoryListCall) Return(arg0 []*domain.PersonalAccessToken, arg1 error) *MockPersonalAccessTokenRepositoryListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPersonalAccessTokenRepositoryListCall) Do(f func(context.Context, database.QueryExecutor, ...database.QueryOpts) ([]*domain.PersonalAccessToken, error)) *MockPersonalAccessTokenRepositoryListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPersonalAccessTokenRepositoryListCall) DoAndReturn(f func(context.Context, database.QueryExecutor, ...database.QueryOpts) ([]*domain.PersonalAccessToken, error)) *MockPersonalAccessTokenRepositoryListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrimaryKeyCondition mocks base method.
func (m *MockPersonalAccessTokenRepository) PrimaryKeyCondition(instanceID, tokenID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrimaryKeyCondition", instanceID, tokenID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// PrimaryKeyCondition indicates an expected call of PrimaryKeyCondition.
func (mr *MockPersonalAccessTokenRepositoryMockRecorder) PrimaryKeyCondition(instanceID, tokenID any) *MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrimaryKeyCondition", reflect.TypeOf((*MockPersonalAccessTokenRepository)(nil).PrimaryKeyCondition), instanceID, tokenID)
	return &MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall{Call: call}
}

// MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall wrap *gomock.Call
type MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall) Return(arg0 database.Condition) *MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall) Do(f func(string, string) database.Condition) *MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall) DoAndReturn(f func(string, string) database.Condition) *MockPersonalAccessTokenRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UserIDCondition mocks base method.
func (m *MockPersonalAccessTokenRepository) UserIDCondition(userID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UserIDCondition", userID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// UserIDCondition indicates an expected call of UserIDCondition.
func (mr *MockPersonalAccessTokenRepositoryMockRecorder) UserIDCondition(userID any) *MockPersonalAccessTokenRepositoryUserIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UserIDCondition", reflect.TypeOf((*MockPersonalAccessTokenRepository)(nil).UserIDCondition), userID)
	return &MockPersonalAccessTokenRepositoryUserIDConditionCall{Call: call}
}

// MockPersonalAccessTokenRepositoryUserIDConditionCall wrap *gomock.Call
type MockPersonalAccessTokenRepositoryUserIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPersonalAccessTokenRepositoryUserIDConditionCall) Return(arg0 database.Condition) *MockPersonalAccessTokenRepositoryUserIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPersonalAccessTokenRepositoryUserIDConditionCall) Do(f func(string) database.Condition) *MockPersonalAccessTokenRepositoryUserIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPersonalAccessTokenRepositoryUserIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockPersonalAccessTokenRepositoryUserIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
