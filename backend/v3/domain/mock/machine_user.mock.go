// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/zitadel/zitadel/backend/v3/domain (interfaces: MachineUserRepository)
//
// Generated by this command:
//
//	mockgen -typed -package domainmock -destination ./mock/machine_user.mock.go . MachineUserRepository
//

// Package domainmock is a generated GoMock package.
package domainmock

import (
	context "context"
	reflect "reflect"
	time "time"

	domain "github.com/zitadel/zitadel/backend/v3/domain"
	database "github.com/zitadel/zitadel/backend/v3/storage/database"
	gomock "go.uber.org/mock/gomock"
)

// MockMachineUserRepository is a mock of MachineUserRepository interface.
type MockMachineUserRepository struct {
	ctrl     *gomock.Controller
	recorder *MockMachineUserRepositoryMockRecorder
	isgomock struct{}
}

// MockMachineUserRepositoryMockRecorder is the mock recorder for MockMachineUserRepository.
type MockMachineUserRepositoryMockRecorder struct {
	mock *MockMachineUserRepository
}

// NewMockMachineUserRepository creates a new mock instance.
func NewMockMachineUserRepository(ctrl *gomock.Controller) *MockMachineUserRepository {
	mock := &MockMachineUserRepository{ctrl: ctrl}
	mock.recorder = &MockMachineUserRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMachineUserRepository) EXPECT() *MockMachineUserRepositoryMockRecorder {
	return m.recorder
}

// AddKey mocks base method.
func (m *MockMachineUserRepository) AddKey(key *domain.MachineKey) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddKey", key)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// AddKey indicates an expected call of AddKey.
func (mr *MockMachineUserRepositoryMockRecorder) AddKey(key any) *MockMachineUserRepositoryAddKeyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddKey", reflect.TypeOf((*MockMachineUserRepository)(nil).AddKey), key)
	return &MockMachineUserRepositoryAddKeyCall{Call: call}
}

// MockMachineUserRepositoryAddKeyCall wrap *gomock.Call
type MockMachineUserRepositoryAddKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryAddKeyCall) Return(arg0 database.Change) *MockMachineUserRepositoryAddKeyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryAddKeyCall) Do(f func(*domain.MachineKey) database.Change) *MockMachineUserRepositoryAddKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryAddKeyCall) DoAndReturn(f func(*domain.MachineKey) database.Change) *MockMachineUserRepositoryAddKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddMetadata mocks base method.
func (m *MockMachineUserRepository) AddMetadata(metadata ...*domain.Metadata) database.Change {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range metadata {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddMetadata", varargs...)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// AddMetadata indicates an expected call of AddMetadata.
func (mr *MockMachineUserRepositoryMockRecorder) AddMetadata(metadata ...any) *MockMachineUserRepositoryAddMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddMetadata", reflect.TypeOf((*MockMachineUserRepository)(nil).AddMetadata), metadata...)
	return &MockMachineUserRepositoryAddMetadataCall{Call: call}
}

// MockMachineUserRepositoryAddMetadataCall wrap *gomock.Call
type MockMachineUserRepositoryAddMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryAddMetadataCall) Return(arg0 database.Change) *MockMachineUserRepositoryAddMetadataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryAddMetadataCall) Do(f func(...*domain.Metadata) database.Change) *MockMachineUserRepositoryAddMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryAddMetadataCall) DoAndReturn(f func(...*domain.Metadata) database.Change) *MockMachineUserRepositoryAddMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddPersonalAccessToken mocks base method.
func (m *MockMachineUserRepository) AddPersonalAccessToken(pat *domain.PersonalAccessToken) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddPersonalAccessToken", pat)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// AddPersonalAccessToken indicates an expected call of AddPersonalAccessToken.
func (mr *MockMachineUserRepositoryMockRecorder) AddPersonalAccessToken(pat any) *MockMachineUserRepositoryAddPersonalAccessTokenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddPersonalAccessToken", reflect.TypeOf((*MockMachineUserRepository)(nil).AddPersonalAccessToken), pat)
	return &MockMachineUserRepositoryAddPersonalAccessTokenCall{Call: call}
}

// MockMachineUserRepositoryAddPersonalAccessTokenCall wrap *gomock.Call
type MockMachineUserRepositoryAddPersonalAccessTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryAddPersonalAccessTokenCall) Return(arg0 database.Change) *MockMachineUserRepositoryAddPersonalAccessTokenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryAddPersonalAccessTokenCall) Do(f func(*domain.PersonalAccessToken) database.Change) *MockMachineUserRepositoryAddPersonalAccessTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryAddPersonalAccessTokenCall) DoAndReturn(f func(*domain.PersonalAccessToken) database.Change) *MockMachineUserRepositoryAddPersonalAccessTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreatedAtColumn mocks base method.
func (m *MockMachineUserRepository) CreatedAtColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreatedAtColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// CreatedAtColumn indicates an expected call of CreatedAtColumn.
func (mr *MockMachineUserRepositoryMockRecorder) CreatedAtColumn() *MockMachineUserRepositoryCreatedAtColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatedAtColumn", reflect.TypeOf((*MockMachineUserRepository)(nil).CreatedAtColumn))
	return &MockMachineUserRepositoryCreatedAtColumnCall{Call: call}
}

// MockMachineUserRepositoryCreatedAtColumnCall wrap *gomock.Call
type MockMachineUserRepositoryCreatedAtColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryCreatedAtColumnCall) Return(arg0 database.Column) *MockMachineUserRepositoryCreatedAtColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryCreatedAtColumnCall) Do(f func() database.Column) *MockMachineUserRepositoryCreatedAtColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryCreatedAtColumnCall) DoAndReturn(f func() database.Column) *MockMachineUserRepositoryCreatedAtColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ExistsMetadata mocks base method.
func (m *MockMachineUserRepository) ExistsMetadata(condition database.Condition) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExistsMetadata", condition)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// ExistsMetadata indicates an expected call of ExistsMetadata.
func (mr *MockMachineUserRepositoryMockRecorder) ExistsMetadata(condition any) *MockMachineUserRepositoryExistsMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExistsMetadata", reflect.TypeOf((*MockMachineUserRepository)(nil).ExistsMetadata), condition)
	return &MockMachineUserRepositoryExistsMetadataCall{Call: call}
}

// MockMachineUserRepositoryExistsMetadataCall wrap *gomock.Call
type MockMachineUserRepositoryExistsMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryExistsMetadataCall) Return(arg0 database.Condition) *MockMachineUserRepositoryExistsMetadataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryExistsMetadataCall) Do(f func(database.Condition) database.Condition) *MockMachineUserRepositoryExistsMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryExistsMetadataCall) DoAndReturn(f func(database.Condition) database.Condition) *MockMachineUserRepositoryExistsMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IDColumn mocks base method.
func (m *MockMachineUserRepository) IDColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IDColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// IDColumn indicates an expected call of IDColumn.
func (mr *MockMachineUserRepositoryMockRecorder) IDColumn() *MockMachineUserRepositoryIDColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IDColumn", reflect.TypeOf((*MockMachineUserRepository)(nil).IDColumn))
	return &MockMachineUserRepositoryIDColumnCall{Call: call}
}

// MockMachineUserRepositoryIDColumnCall wrap *gomock.Call
type MockMachineUserRepositoryIDColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryIDColumnCall) Return(arg0 database.Column) *MockMachineUserRepositoryIDColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryIDColumnCall) Do(f func() database.Column) *MockMachineUserRepositoryIDColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryIDColumnCall) DoAndReturn(f func() database.Column) *MockMachineUserRepositoryIDColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IDCondition mocks base method.
func (m *MockMachineUserRepository) IDCondition(userID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IDCondition", userID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// IDCondition indicates an expected call of IDCondition.
func (mr *MockMachineUserRepositoryMockRecorder) IDCondition(userID any) *MockMachineUserRepositoryIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IDCondition", reflect.TypeOf((*MockMachineUserRepository)(nil).IDCondition), userID)
	return &MockMachineUserRepositoryIDConditionCall{Call: call}
}

// MockMachineUserRepositoryIDConditionCall wrap *gomock.Call
type MockMachineUserRepositoryIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryIDConditionCall) Return(arg0 database.Condition) *MockMachineUserRepositoryIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryIDConditionCall) Do(f func(string) database.Condition) *MockMachineUserRepositoryIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockMachineUserRepositoryIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InstanceIDColumn mocks base method.
func (m *MockMachineUserRepository) InstanceIDColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceIDColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// InstanceIDColumn indicates an expected call of InstanceIDColumn.
func (mr *MockMachineUserRepositoryMockRecorder) InstanceIDColumn() *MockMachineUserRepositoryInstanceIDColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceIDColumn", reflect.TypeOf((*MockMachineUserRepository)(nil).InstanceIDColumn))
	return &MockMachineUserRepositoryInstanceIDColumnCall{Call: call}
}

// MockMachineUserRepositoryInstanceIDColumnCall wrap *gomock.Call
type MockMachineUserRepositoryInstanceIDColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryInstanceIDColumnCall) Return(arg0 database.Column) *MockMachineUserRepositoryInstanceIDColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryInstanceIDColumnCall) Do(f func() database.Column) *MockMachineUserRepositoryInstanceIDColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryInstanceIDColumnCall) DoAndReturn(f func() database.Column) *MockMachineUserRepositoryInstanceIDColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InstanceIDCondition mocks base method.
func (m *MockMachineUserRepository) InstanceIDCondition(instanceID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstanceIDCondition", instanceID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// InstanceIDCondition indicates an expected call of InstanceIDCondition.
func (mr *MockMachineUserRepositoryMockRecorder) InstanceIDCondition(instanceID any) *MockMachineUserRepositoryInstanceIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstanceIDCondition", reflect.TypeOf((*MockMachineUserRepository)(nil).InstanceIDCondition), instanceID)
	return &MockMachineUserRepositoryInstanceIDConditionCall{Call: call}
}

// MockMachineUserRepositoryInstanceIDConditionCall wrap *gomock.Call
type MockMachineUserRepositoryInstanceIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryInstanceIDConditionCall) Return(arg0 database.Condition) *MockMachineUserRepositoryInstanceIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryInstanceIDConditionCall) Do(f func(string) database.Condition) *MockMachineUserRepositoryInstanceIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryInstanceIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockMachineUserRepositoryInstanceIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LoginNameCondition mocks base method.
func (m *MockMachineUserRepository) LoginNameCondition(op database.TextOperation, loginName string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoginNameCondition", op, loginName)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// LoginNameCondition indicates an expected call of LoginNameCondition.
func (mr *MockMachineUserRepositoryMockRecorder) LoginNameCondition(op, loginName any) *MockMachineUserRepositoryLoginNameConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoginNameCondition", reflect.TypeOf((*MockMachineUserRepository)(nil).LoginNameCondition), op, loginName)
	return &MockMachineUserRepositoryLoginNameConditionCall{Call: call}
}

// MockMachineUserRepositoryLoginNameConditionCall wrap *gomock.Call
type MockMachineUserRepositoryLoginNameConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryLoginNameConditionCall) Return(arg0 database.Condition) *MockMachineUserRepositoryLoginNameConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryLoginNameConditionCall) Do(f func(database.TextOperation, string) database.Condition) *MockMachineUserRepositoryLoginNameConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryLoginNameConditionCall) DoAndReturn(f func(database.TextOperation, string) database.Condition) *MockMachineUserRepositoryLoginNameConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MetadataConditions mocks base method.
func (m *MockMachineUserRepository) MetadataConditions() domain.UserMetadataConditions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MetadataConditions")
	ret0, _ := ret[0].(domain.UserMetadataConditions)
	return ret0
}

// MetadataConditions indicates an expected call of MetadataConditions.
func (mr *MockMachineUserRepositoryMockRecorder) MetadataConditions() *MockMachineUserRepositoryMetadataConditionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetadataConditions", reflect.TypeOf((*MockMachineUserRepository)(nil).MetadataConditions))
	return &MockMachineUserRepositoryMetadataConditionsCall{Call: call}
}

// MockMachineUserRepositoryMetadataConditionsCall wrap *gomock.Call
type MockMachineUserRepositoryMetadataConditionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryMetadataConditionsCall) Return(arg0 domain.UserMetadataConditions) *MockMachineUserRepositoryMetadataConditionsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryMetadataConditionsCall) Do(f func() domain.UserMetadataConditions) *MockMachineUserRepositoryMetadataConditionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryMetadataConditionsCall) DoAndReturn(f func() domain.UserMetadataConditions) *MockMachineUserRepositoryMetadataConditionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// OrganizationIDCondition mocks base method.
func (m *MockMachineUserRepository) OrganizationIDCondition(orgID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "OrganizationIDCondition", orgID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// OrganizationIDCondition indicates an expected call of OrganizationIDCondition.
func (mr *MockMachineUserRepositoryMockRecorder) OrganizationIDCondition(orgID any) *MockMachineUserRepositoryOrganizationIDConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OrganizationIDCondition", reflect.TypeOf((*MockMachineUserRepository)(nil).OrganizationIDCondition), orgID)
	return &MockMachineUserRepositoryOrganizationIDConditionCall{Call: call}
}

// MockMachineUserRepositoryOrganizationIDConditionCall wrap *gomock.Call
type MockMachineUserRepositoryOrganizationIDConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryOrganizationIDConditionCall) Return(arg0 database.Condition) *MockMachineUserRepositoryOrganizationIDConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryOrganizationIDConditionCall) Do(f func(string) database.Condition) *MockMachineUserRepositoryOrganizationIDConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryOrganizationIDConditionCall) DoAndReturn(f func(string) database.Condition) *MockMachineUserRepositoryOrganizationIDConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrimaryKeyColumns mocks base method.
func (m *MockMachineUserRepository) PrimaryKeyColumns() []database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrimaryKeyColumns")
	ret0, _ := ret[0].([]database.Column)
	return ret0
}

// PrimaryKeyColumns indicates an expected call of PrimaryKeyColumns.
func (mr *MockMachineUserRepositoryMockRecorder) PrimaryKeyColumns() *MockMachineUserRepositoryPrimaryKeyColumnsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrimaryKeyColumns", reflect.TypeOf((*MockMachineUserRepository)(nil).PrimaryKeyColumns))
	return &MockMachineUserRepositoryPrimaryKeyColumnsCall{Call: call}
}

// MockMachineUserRepositoryPrimaryKeyColumnsCall wrap *gomock.Call
type MockMachineUserRepositoryPrimaryKeyColumnsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryPrimaryKeyColumnsCall) Return(arg0 []database.Column) *MockMachineUserRepositoryPrimaryKeyColumnsCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryPrimaryKeyColumnsCall) Do(f func() []database.Column) *MockMachineUserRepositoryPrimaryKeyColumnsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryPrimaryKeyColumnsCall) DoAndReturn(f func() []database.Column) *MockMachineUserRepositoryPrimaryKeyColumnsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PrimaryKeyCondition mocks base method.
func (m *MockMachineUserRepository) PrimaryKeyCondition(instanceID, userID string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PrimaryKeyCondition", instanceID, userID)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// PrimaryKeyCondition indicates an expected call of PrimaryKeyCondition.
func (mr *MockMachineUserRepositoryMockRecorder) PrimaryKeyCondition(instanceID, userID any) *MockMachineUserRepositoryPrimaryKeyConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PrimaryKeyCondition", reflect.TypeOf((*MockMachineUserRepository)(nil).PrimaryKeyCondition), instanceID, userID)
	return &MockMachineUserRepositoryPrimaryKeyConditionCall{Call: call}
}

// MockMachineUserRepositoryPrimaryKeyConditionCall wrap *gomock.Call
type MockMachineUserRepositoryPrimaryKeyConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryPrimaryKeyConditionCall) Return(arg0 database.Condition) *MockMachineUserRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryPrimaryKeyConditionCall) Do(f func(string, string) database.Condition) *MockMachineUserRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryPrimaryKeyConditionCall) DoAndReturn(f func(string, string) database.Condition) *MockMachineUserRepositoryPrimaryKeyConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveKey mocks base method.
func (m *MockMachineUserRepository) RemoveKey(id string) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveKey", id)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// RemoveKey indicates an expected call of RemoveKey.
func (mr *MockMachineUserRepositoryMockRecorder) RemoveKey(id any) *MockMachineUserRepositoryRemoveKeyCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveKey", reflect.TypeOf((*MockMachineUserRepository)(nil).RemoveKey), id)
	return &MockMachineUserRepositoryRemoveKeyCall{Call: call}
}

// MockMachineUserRepositoryRemoveKeyCall wrap *gomock.Call
type MockMachineUserRepositoryRemoveKeyCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryRemoveKeyCall) Return(arg0 database.Change) *MockMachineUserRepositoryRemoveKeyCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryRemoveKeyCall) Do(f func(string) database.Change) *MockMachineUserRepositoryRemoveKeyCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryRemoveKeyCall) DoAndReturn(f func(string) database.Change) *MockMachineUserRepositoryRemoveKeyCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveMetadata mocks base method.
func (m *MockMachineUserRepository) RemoveMetadata(condition database.Condition) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveMetadata", condition)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// RemoveMetadata indicates an expected call of RemoveMetadata.
func (mr *MockMachineUserRepositoryMockRecorder) RemoveMetadata(condition any) *MockMachineUserRepositoryRemoveMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveMetadata", reflect.TypeOf((*MockMachineUserRepository)(nil).RemoveMetadata), condition)
	return &MockMachineUserRepositoryRemoveMetadataCall{Call: call}
}

// MockMachineUserRepositoryRemoveMetadataCall wrap *gomock.Call
type MockMachineUserRepositoryRemoveMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryRemoveMetadataCall) Return(arg0 database.Change) *MockMachineUserRepositoryRemoveMetadataCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryRemoveMetadataCall) Do(f func(database.Condition) database.Change) *MockMachineUserRepositoryRemoveMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryRemoveMetadataCall) DoAndReturn(f func(database.Condition) database.Change) *MockMachineUserRepositoryRemoveMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemovePersonalAccessToken mocks base method.
func (m *MockMachineUserRepository) RemovePersonalAccessToken(id string) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemovePersonalAccessToken", id)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// RemovePersonalAccessToken indicates an expected call of RemovePersonalAccessToken.
func (mr *MockMachineUserRepositoryMockRecorder) RemovePersonalAccessToken(id any) *MockMachineUserRepositoryRemovePersonalAccessTokenCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemovePersonalAccessToken", reflect.TypeOf((*MockMachineUserRepository)(nil).RemovePersonalAccessToken), id)
	return &MockMachineUserRepositoryRemovePersonalAccessTokenCall{Call: call}
}

// MockMachineUserRepositoryRemovePersonalAccessTokenCall wrap *gomock.Call
type MockMachineUserRepositoryRemovePersonalAccessTokenCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryRemovePersonalAccessTokenCall) Return(arg0 database.Change) *MockMachineUserRepositoryRemovePersonalAccessTokenCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryRemovePersonalAccessTokenCall) Do(f func(string) database.Change) *MockMachineUserRepositoryRemovePersonalAccessTokenCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryRemovePersonalAccessTokenCall) DoAndReturn(f func(string) database.Change) *MockMachineUserRepositoryRemovePersonalAccessTokenCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetAccessTokenType mocks base method.
func (m *MockMachineUserRepository) SetAccessTokenType(tokenType domain.AccessTokenType) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetAccessTokenType", tokenType)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetAccessTokenType indicates an expected call of SetAccessTokenType.
func (mr *MockMachineUserRepositoryMockRecorder) SetAccessTokenType(tokenType any) *MockMachineUserRepositorySetAccessTokenTypeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAccessTokenType", reflect.TypeOf((*MockMachineUserRepository)(nil).SetAccessTokenType), tokenType)
	return &MockMachineUserRepositorySetAccessTokenTypeCall{Call: call}
}

// MockMachineUserRepositorySetAccessTokenTypeCall wrap *gomock.Call
type MockMachineUserRepositorySetAccessTokenTypeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositorySetAccessTokenTypeCall) Return(arg0 database.Change) *MockMachineUserRepositorySetAccessTokenTypeCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositorySetAccessTokenTypeCall) Do(f func(domain.AccessTokenType) database.Change) *MockMachineUserRepositorySetAccessTokenTypeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositorySetAccessTokenTypeCall) DoAndReturn(f func(domain.AccessTokenType) database.Change) *MockMachineUserRepositorySetAccessTokenTypeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetDescription mocks base method.
func (m *MockMachineUserRepository) SetDescription(description string) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDescription", description)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetDescription indicates an expected call of SetDescription.
func (mr *MockMachineUserRepositoryMockRecorder) SetDescription(description any) *MockMachineUserRepositorySetDescriptionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDescription", reflect.TypeOf((*MockMachineUserRepository)(nil).SetDescription), description)
	return &MockMachineUserRepositorySetDescriptionCall{Call: call}
}

// MockMachineUserRepositorySetDescriptionCall wrap *gomock.Call
type MockMachineUserRepositorySetDescriptionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositorySetDescriptionCall) Return(arg0 database.Change) *MockMachineUserRepositorySetDescriptionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositorySetDescriptionCall) Do(f func(string) database.Change) *MockMachineUserRepositorySetDescriptionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositorySetDescriptionCall) DoAndReturn(f func(string) database.Change) *MockMachineUserRepositorySetDescriptionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetName mocks base method.
func (m *MockMachineUserRepository) SetName(name string) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetName", name)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetName indicates an expected call of SetName.
func (mr *MockMachineUserRepositoryMockRecorder) SetName(name any) *MockMachineUserRepositorySetNameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetName", reflect.TypeOf((*MockMachineUserRepository)(nil).SetName), name)
	return &MockMachineUserRepositorySetNameCall{Call: call}
}

// MockMachineUserRepositorySetNameCall wrap *gomock.Call
type MockMachineUserRepositorySetNameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositorySetNameCall) Return(arg0 database.Change) *MockMachineUserRepositorySetNameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositorySetNameCall) Do(f func(string) database.Change) *MockMachineUserRepositorySetNameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositorySetNameCall) DoAndReturn(f func(string) database.Change) *MockMachineUserRepositorySetNameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetSecret mocks base method.
func (m *MockMachineUserRepository) SetSecret(secret *string) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetSecret", secret)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetSecret indicates an expected call of SetSecret.
func (mr *MockMachineUserRepositoryMockRecorder) SetSecret(secret any) *MockMachineUserRepositorySetSecretCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSecret", reflect.TypeOf((*MockMachineUserRepository)(nil).SetSecret), secret)
	return &MockMachineUserRepositorySetSecretCall{Call: call}
}

// MockMachineUserRepositorySetSecretCall wrap *gomock.Call
type MockMachineUserRepositorySetSecretCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositorySetSecretCall) Return(arg0 database.Change) *MockMachineUserRepositorySetSecretCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositorySetSecretCall) Do(f func(*string) database.Change) *MockMachineUserRepositorySetSecretCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositorySetSecretCall) DoAndReturn(f func(*string) database.Change) *MockMachineUserRepositorySetSecretCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetState mocks base method.
func (m *MockMachineUserRepository) SetState(state domain.UserState) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetState", state)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetState indicates an expected call of SetState.
func (mr *MockMachineUserRepositoryMockRecorder) SetState(state any) *MockMachineUserRepositorySetStateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetState", reflect.TypeOf((*MockMachineUserRepository)(nil).SetState), state)
	return &MockMachineUserRepositorySetStateCall{Call: call}
}

// MockMachineUserRepositorySetStateCall wrap *gomock.Call
type MockMachineUserRepositorySetStateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositorySetStateCall) Return(arg0 database.Change) *MockMachineUserRepositorySetStateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositorySetStateCall) Do(f func(domain.UserState) database.Change) *MockMachineUserRepositorySetStateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositorySetStateCall) DoAndReturn(f func(domain.UserState) database.Change) *MockMachineUserRepositorySetStateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUpdatedAt mocks base method.
func (m *MockMachineUserRepository) SetUpdatedAt(updatedAt time.Time) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUpdatedAt", updatedAt)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetUpdatedAt indicates an expected call of SetUpdatedAt.
func (mr *MockMachineUserRepositoryMockRecorder) SetUpdatedAt(updatedAt any) *MockMachineUserRepositorySetUpdatedAtCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUpdatedAt", reflect.TypeOf((*MockMachineUserRepository)(nil).SetUpdatedAt), updatedAt)
	return &MockMachineUserRepositorySetUpdatedAtCall{Call: call}
}

// MockMachineUserRepositorySetUpdatedAtCall wrap *gomock.Call
type MockMachineUserRepositorySetUpdatedAtCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositorySetUpdatedAtCall) Return(arg0 database.Change) *MockMachineUserRepositorySetUpdatedAtCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositorySetUpdatedAtCall) Do(f func(time.Time) database.Change) *MockMachineUserRepositorySetUpdatedAtCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositorySetUpdatedAtCall) DoAndReturn(f func(time.Time) database.Change) *MockMachineUserRepositorySetUpdatedAtCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetUsername mocks base method.
func (m *MockMachineUserRepository) SetUsername(username string) database.Change {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetUsername", username)
	ret0, _ := ret[0].(database.Change)
	return ret0
}

// SetUsername indicates an expected call of SetUsername.
func (mr *MockMachineUserRepositoryMockRecorder) SetUsername(username any) *MockMachineUserRepositorySetUsernameCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetUsername", reflect.TypeOf((*MockMachineUserRepository)(nil).SetUsername), username)
	return &MockMachineUserRepositorySetUsernameCall{Call: call}
}

// MockMachineUserRepositorySetUsernameCall wrap *gomock.Call
type MockMachineUserRepositorySetUsernameCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositorySetUsernameCall) Return(arg0 database.Change) *MockMachineUserRepositorySetUsernameCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositorySetUsernameCall) Do(f func(string) database.Change) *MockMachineUserRepositorySetUsernameCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositorySetUsernameCall) DoAndReturn(f func(string) database.Change) *MockMachineUserRepositorySetUsernameCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StateColumn mocks base method.
func (m *MockMachineUserRepository) StateColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StateColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// StateColumn indicates an expected call of StateColumn.
func (mr *MockMachineUserRepositoryMockRecorder) StateColumn() *MockMachineUserRepositoryStateColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StateColumn", reflect.TypeOf((*MockMachineUserRepository)(nil).StateColumn))
	return &MockMachineUserRepositoryStateColumnCall{Call: call}
}

// MockMachineUserRepositoryStateColumnCall wrap *gomock.Call
type MockMachineUserRepositoryStateColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryStateColumnCall) Return(arg0 database.Column) *MockMachineUserRepositoryStateColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryStateColumnCall) Do(f func() database.Column) *MockMachineUserRepositoryStateColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryStateColumnCall) DoAndReturn(f func() database.Column) *MockMachineUserRepositoryStateColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// StateCondition mocks base method.
func (m *MockMachineUserRepository) StateCondition(state domain.UserState) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StateCondition", state)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// StateCondition indicates an expected call of StateCondition.
func (mr *MockMachineUserRepositoryMockRecorder) StateCondition(state any) *MockMachineUserRepositoryStateConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StateCondition", reflect.TypeOf((*MockMachineUserRepository)(nil).StateCondition), state)
	return &MockMachineUserRepositoryStateConditionCall{Call: call}
}

// MockMachineUserRepositoryStateConditionCall wrap *gomock.Call
type MockMachineUserRepositoryStateConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryStateConditionCall) Return(arg0 database.Condition) *MockMachineUserRepositoryStateConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryStateConditionCall) Do(f func(domain.UserState) database.Condition) *MockMachineUserRepositoryStateConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryStateConditionCall) DoAndReturn(f func(domain.UserState) database.Condition) *MockMachineUserRepositoryStateConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TypeColumn mocks base method.
func (m *MockMachineUserRepository) TypeColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TypeColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// TypeColumn indicates an expected call of TypeColumn.
func (mr *MockMachineUserRepositoryMockRecorder) TypeColumn() *MockMachineUserRepositoryTypeColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TypeColumn", reflect.TypeOf((*MockMachineUserRepository)(nil).TypeColumn))
	return &MockMachineUserRepositoryTypeColumnCall{Call: call}
}

// MockMachineUserRepositoryTypeColumnCall wrap *gomock.Call
type MockMachineUserRepositoryTypeColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryTypeColumnCall) Return(arg0 database.Column) *MockMachineUserRepositoryTypeColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryTypeColumnCall) Do(f func() database.Column) *MockMachineUserRepositoryTypeColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryTypeColumnCall) DoAndReturn(f func() database.Column) *MockMachineUserRepositoryTypeColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TypeCondition mocks base method.
func (m *MockMachineUserRepository) TypeCondition(userType domain.UserType) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TypeCondition", userType)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// TypeCondition indicates an expected call of TypeCondition.
func (mr *MockMachineUserRepositoryMockRecorder) TypeCondition(userType any) *MockMachineUserRepositoryTypeConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TypeCondition", reflect.TypeOf((*MockMachineUserRepository)(nil).TypeCondition), userType)
	return &MockMachineUserRepositoryTypeConditionCall{Call: call}
}

// MockMachineUserRepositoryTypeConditionCall wrap *gomock.Call
type MockMachineUserRepositoryTypeConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryTypeConditionCall) Return(arg0 database.Condition) *MockMachineUserRepositoryTypeConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryTypeConditionCall) Do(f func(domain.UserType) database.Condition) *MockMachineUserRepositoryTypeConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryTypeConditionCall) DoAndReturn(f func(domain.UserType) database.Condition) *MockMachineUserRepositoryTypeConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Update mocks base method.
func (m *MockMachineUserRepository) Update(ctx context.Context, client database.QueryExecutor, condition database.Condition, changes ...database.Change) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, client, condition}
	for _, a := range changes {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update.
func (mr *MockMachineUserRepositoryMockRecorder) Update(ctx, client, condition any, changes ...any) *MockMachineUserRepositoryUpdateCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, client, condition}, changes...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockMachineUserRepository)(nil).Update), varargs...)
	return &MockMachineUserRepositoryUpdateCall{Call: call}
}

// MockMachineUserRepositoryUpdateCall wrap *gomock.Call
type MockMachineUserRepositoryUpdateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryUpdateCall) Return(arg0 int64, arg1 error) *MockMachineUserRepositoryUpdateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryUpdateCall) Do(f func(context.Context, database.QueryExecutor, database.Condition, ...database.Change) (int64, error)) *MockMachineUserRepositoryUpdateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryUpdateCall) DoAndReturn(f func(context.Context, database.QueryExecutor, database.Condition, ...database.Change) (int64, error)) *MockMachineUserRepositoryUpdateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UsernameColumn mocks base method.
func (m *MockMachineUserRepository) UsernameColumn() database.Column {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UsernameColumn")
	ret0, _ := ret[0].(database.Column)
	return ret0
}

// UsernameColumn indicates an expected call of UsernameColumn.
func (mr *MockMachineUserRepositoryMockRecorder) UsernameColumn() *MockMachineUserRepositoryUsernameColumnCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsernameColumn", reflect.TypeOf((*MockMachineUserRepository)(nil).UsernameColumn))
	return &MockMachineUserRepositoryUsernameColumnCall{Call: call}
}

// MockMachineUserRepositoryUsernameColumnCall wrap *gomock.Call
type MockMachineUserRepositoryUsernameColumnCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryUsernameColumnCall) Return(arg0 database.Column) *MockMachineUserRepositoryUsernameColumnCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryUsernameColumnCall) Do(f func() database.Column) *MockMachineUserRepositoryUsernameColumnCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryUsernameColumnCall) DoAndReturn(f func() database.Column) *MockMachineUserRepositoryUsernameColumnCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UsernameCondition mocks base method.
func (m *MockMachineUserRepository) UsernameCondition(op database.TextOperation, username string) database.Condition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UsernameCondition", op, username)
	ret0, _ := ret[0].(database.Condition)
	return ret0
}

// UsernameCondition indicates an expected call of UsernameCondition.
func (mr *MockMachineUserRepositoryMockRecorder) UsernameCondition(op, username any) *MockMachineUserRepositoryUsernameConditionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsernameCondition", reflect.TypeOf((*MockMachineUserRepository)(nil).UsernameCondition), op, username)
	return &MockMachineUserRepositoryUsernameConditionCall{Call: call}
}

// MockMachineUserRepositoryUsernameConditionCall wrap *gomock.Call
type MockMachineUserRepositoryUsernameConditionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockMachineUserRepositoryUsernameConditionCall) Return(arg0 database.Condition) *MockMachineUserRepositoryUsernameConditionCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockMachineUserRepositoryUsernameConditionCall) Do(f func(database.TextOperation, string) database.Condition) *MockMachineUserRepositoryUsernameConditionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockMachineUserRepositoryUsernameConditionCall) DoAndReturn(f func(database.TextOperation, string) database.Condition) *MockMachineUserRepositoryUsernameConditionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
