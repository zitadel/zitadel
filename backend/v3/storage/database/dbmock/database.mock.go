// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/zitadel/zitadel/backend/v3/storage/database (interfaces: Pool,Client,Row,Rows,Transaction)
//
// Generated by this command:
//
//	mockgen -typed -package dbmock -destination ./dbmock/database.mock.go github.com/zitadel/zitadel/backend/v3/storage/database Pool,Client,Row,Rows,Transaction
//

// Package dbmock is a generated GoMock package.
package dbmock

import (
	context "context"
	reflect "reflect"

	database "github.com/zitadel/zitadel/backend/v3/storage/database"
	gomock "go.uber.org/mock/gomock"
)

// MockPool is a mock of Pool interface.
type MockPool struct {
	ctrl     *gomock.Controller
	recorder *MockPoolMockRecorder
}

// MockPoolMockRecorder is the mock recorder for MockPool.
type MockPoolMockRecorder struct {
	mock *MockPool
}

// NewMockPool creates a new mock instance.
func NewMockPool(ctrl *gomock.Controller) *MockPool {
	mock := &MockPool{ctrl: ctrl}
	mock.recorder = &MockPoolMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPool) EXPECT() *MockPoolMockRecorder {
	return m.recorder
}

// Acquire mocks base method.
func (m *MockPool) Acquire(arg0 context.Context) (database.Client, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Acquire", arg0)
	ret0, _ := ret[0].(database.Client)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Acquire indicates an expected call of Acquire.
func (mr *MockPoolMockRecorder) Acquire(arg0 any) *MockPoolAcquireCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Acquire", reflect.TypeOf((*MockPool)(nil).Acquire), arg0)
	return &MockPoolAcquireCall{Call: call}
}

// MockPoolAcquireCall wrap *gomock.Call
type MockPoolAcquireCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolAcquireCall) Return(arg0 database.Client, arg1 error) *MockPoolAcquireCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolAcquireCall) Do(f func(context.Context) (database.Client, error)) *MockPoolAcquireCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolAcquireCall) DoAndReturn(f func(context.Context) (database.Client, error)) *MockPoolAcquireCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Begin mocks base method.
func (m *MockPool) Begin(arg0 context.Context, arg1 *database.TransactionOptions) (database.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", arg0, arg1)
	ret0, _ := ret[0].(database.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockPoolMockRecorder) Begin(arg0, arg1 any) *MockPoolBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockPool)(nil).Begin), arg0, arg1)
	return &MockPoolBeginCall{Call: call}
}

// MockPoolBeginCall wrap *gomock.Call
type MockPoolBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolBeginCall) Return(arg0 database.Transaction, arg1 error) *MockPoolBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolBeginCall) Do(f func(context.Context, *database.TransactionOptions) (database.Transaction, error)) *MockPoolBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolBeginCall) DoAndReturn(f func(context.Context, *database.TransactionOptions) (database.Transaction, error)) *MockPoolBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Close mocks base method.
func (m *MockPool) Close(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockPoolMockRecorder) Close(arg0 any) *MockPoolCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockPool)(nil).Close), arg0)
	return &MockPoolCloseCall{Call: call}
}

// MockPoolCloseCall wrap *gomock.Call
type MockPoolCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolCloseCall) Return(arg0 error) *MockPoolCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolCloseCall) Do(f func(context.Context) error) *MockPoolCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolCloseCall) DoAndReturn(f func(context.Context) error) *MockPoolCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockPool) Exec(arg0 context.Context, arg1 string, arg2 ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockPoolMockRecorder) Exec(arg0, arg1 any, arg2 ...any) *MockPoolExecCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockPool)(nil).Exec), varargs...)
	return &MockPoolExecCall{Call: call}
}

// MockPoolExecCall wrap *gomock.Call
type MockPoolExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolExecCall) Return(arg0 int64, arg1 error) *MockPoolExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolExecCall) Do(f func(context.Context, string, ...any) (int64, error)) *MockPoolExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolExecCall) DoAndReturn(f func(context.Context, string, ...any) (int64, error)) *MockPoolExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Migrate mocks base method.
func (m *MockPool) Migrate(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Migrate", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Migrate indicates an expected call of Migrate.
func (mr *MockPoolMockRecorder) Migrate(arg0 any) *MockPoolMigrateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Migrate", reflect.TypeOf((*MockPool)(nil).Migrate), arg0)
	return &MockPoolMigrateCall{Call: call}
}

// MockPoolMigrateCall wrap *gomock.Call
type MockPoolMigrateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolMigrateCall) Return(arg0 error) *MockPoolMigrateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolMigrateCall) Do(f func(context.Context) error) *MockPoolMigrateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolMigrateCall) DoAndReturn(f func(context.Context) error) *MockPoolMigrateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Query mocks base method.
func (m *MockPool) Query(arg0 context.Context, arg1 string, arg2 ...any) (database.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(database.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockPoolMockRecorder) Query(arg0, arg1 any, arg2 ...any) *MockPoolQueryCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockPool)(nil).Query), varargs...)
	return &MockPoolQueryCall{Call: call}
}

// MockPoolQueryCall wrap *gomock.Call
type MockPoolQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolQueryCall) Return(arg0 database.Rows, arg1 error) *MockPoolQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolQueryCall) Do(f func(context.Context, string, ...any) (database.Rows, error)) *MockPoolQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolQueryCall) DoAndReturn(f func(context.Context, string, ...any) (database.Rows, error)) *MockPoolQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryRow mocks base method.
func (m *MockPool) QueryRow(arg0 context.Context, arg1 string, arg2 ...any) database.Row {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(database.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockPoolMockRecorder) QueryRow(arg0, arg1 any, arg2 ...any) *MockPoolQueryRowCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockPool)(nil).QueryRow), varargs...)
	return &MockPoolQueryRowCall{Call: call}
}

// MockPoolQueryRowCall wrap *gomock.Call
type MockPoolQueryRowCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockPoolQueryRowCall) Return(arg0 database.Row) *MockPoolQueryRowCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockPoolQueryRowCall) Do(f func(context.Context, string, ...any) database.Row) *MockPoolQueryRowCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockPoolQueryRowCall) DoAndReturn(f func(context.Context, string, ...any) database.Row) *MockPoolQueryRowCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockClient is a mock of Client interface.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
	mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockClient) Begin(arg0 context.Context, arg1 *database.TransactionOptions) (database.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", arg0, arg1)
	ret0, _ := ret[0].(database.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockClientMockRecorder) Begin(arg0, arg1 any) *MockClientBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockClient)(nil).Begin), arg0, arg1)
	return &MockClientBeginCall{Call: call}
}

// MockClientBeginCall wrap *gomock.Call
type MockClientBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockClientBeginCall) Return(arg0 database.Transaction, arg1 error) *MockClientBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockClientBeginCall) Do(f func(context.Context, *database.TransactionOptions) (database.Transaction, error)) *MockClientBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockClientBeginCall) DoAndReturn(f func(context.Context, *database.TransactionOptions) (database.Transaction, error)) *MockClientBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockClient) Exec(arg0 context.Context, arg1 string, arg2 ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockClientMockRecorder) Exec(arg0, arg1 any, arg2 ...any) *MockClientExecCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockClient)(nil).Exec), varargs...)
	return &MockClientExecCall{Call: call}
}

// MockClientExecCall wrap *gomock.Call
type MockClientExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockClientExecCall) Return(arg0 int64, arg1 error) *MockClientExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockClientExecCall) Do(f func(context.Context, string, ...any) (int64, error)) *MockClientExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockClientExecCall) DoAndReturn(f func(context.Context, string, ...any) (int64, error)) *MockClientExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Migrate mocks base method.
func (m *MockClient) Migrate(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Migrate", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Migrate indicates an expected call of Migrate.
func (mr *MockClientMockRecorder) Migrate(arg0 any) *MockClientMigrateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Migrate", reflect.TypeOf((*MockClient)(nil).Migrate), arg0)
	return &MockClientMigrateCall{Call: call}
}

// MockClientMigrateCall wrap *gomock.Call
type MockClientMigrateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockClientMigrateCall) Return(arg0 error) *MockClientMigrateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockClientMigrateCall) Do(f func(context.Context) error) *MockClientMigrateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockClientMigrateCall) DoAndReturn(f func(context.Context) error) *MockClientMigrateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Query mocks base method.
func (m *MockClient) Query(arg0 context.Context, arg1 string, arg2 ...any) (database.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(database.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockClientMockRecorder) Query(arg0, arg1 any, arg2 ...any) *MockClientQueryCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockClient)(nil).Query), varargs...)
	return &MockClientQueryCall{Call: call}
}

// MockClientQueryCall wrap *gomock.Call
type MockClientQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockClientQueryCall) Return(arg0 database.Rows, arg1 error) *MockClientQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockClientQueryCall) Do(f func(context.Context, string, ...any) (database.Rows, error)) *MockClientQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockClientQueryCall) DoAndReturn(f func(context.Context, string, ...any) (database.Rows, error)) *MockClientQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryRow mocks base method.
func (m *MockClient) QueryRow(arg0 context.Context, arg1 string, arg2 ...any) database.Row {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(database.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockClientMockRecorder) QueryRow(arg0, arg1 any, arg2 ...any) *MockClientQueryRowCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockClient)(nil).QueryRow), varargs...)
	return &MockClientQueryRowCall{Call: call}
}

// MockClientQueryRowCall wrap *gomock.Call
type MockClientQueryRowCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockClientQueryRowCall) Return(arg0 database.Row) *MockClientQueryRowCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockClientQueryRowCall) Do(f func(context.Context, string, ...any) database.Row) *MockClientQueryRowCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockClientQueryRowCall) DoAndReturn(f func(context.Context, string, ...any) database.Row) *MockClientQueryRowCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Release mocks base method.
func (m *MockClient) Release(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Release", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Release indicates an expected call of Release.
func (mr *MockClientMockRecorder) Release(arg0 any) *MockClientReleaseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockClient)(nil).Release), arg0)
	return &MockClientReleaseCall{Call: call}
}

// MockClientReleaseCall wrap *gomock.Call
type MockClientReleaseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockClientReleaseCall) Return(arg0 error) *MockClientReleaseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockClientReleaseCall) Do(f func(context.Context) error) *MockClientReleaseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockClientReleaseCall) DoAndReturn(f func(context.Context) error) *MockClientReleaseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRow is a mock of Row interface.
type MockRow struct {
	ctrl     *gomock.Controller
	recorder *MockRowMockRecorder
}

// MockRowMockRecorder is the mock recorder for MockRow.
type MockRowMockRecorder struct {
	mock *MockRow
}

// NewMockRow creates a new mock instance.
func NewMockRow(ctrl *gomock.Controller) *MockRow {
	mock := &MockRow{ctrl: ctrl}
	mock.recorder = &MockRowMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRow) EXPECT() *MockRowMockRecorder {
	return m.recorder
}

// Scan mocks base method.
func (m *MockRow) Scan(arg0 ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockRowMockRecorder) Scan(arg0 ...any) *MockRowScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockRow)(nil).Scan), arg0...)
	return &MockRowScanCall{Call: call}
}

// MockRowScanCall wrap *gomock.Call
type MockRowScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowScanCall) Return(arg0 error) *MockRowScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowScanCall) Do(f func(...any) error) *MockRowScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowScanCall) DoAndReturn(f func(...any) error) *MockRowScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockRows is a mock of Rows interface.
type MockRows struct {
	ctrl     *gomock.Controller
	recorder *MockRowsMockRecorder
}

// MockRowsMockRecorder is the mock recorder for MockRows.
type MockRowsMockRecorder struct {
	mock *MockRows
}

// NewMockRows creates a new mock instance.
func NewMockRows(ctrl *gomock.Controller) *MockRows {
	mock := &MockRows{ctrl: ctrl}
	mock.recorder = &MockRowsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRows) EXPECT() *MockRowsMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockRows) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockRowsMockRecorder) Close() *MockRowsCloseCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockRows)(nil).Close))
	return &MockRowsCloseCall{Call: call}
}

// MockRowsCloseCall wrap *gomock.Call
type MockRowsCloseCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowsCloseCall) Return(arg0 error) *MockRowsCloseCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowsCloseCall) Do(f func() error) *MockRowsCloseCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowsCloseCall) DoAndReturn(f func() error) *MockRowsCloseCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Err mocks base method.
func (m *MockRows) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockRowsMockRecorder) Err() *MockRowsErrCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockRows)(nil).Err))
	return &MockRowsErrCall{Call: call}
}

// MockRowsErrCall wrap *gomock.Call
type MockRowsErrCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowsErrCall) Return(arg0 error) *MockRowsErrCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowsErrCall) Do(f func() error) *MockRowsErrCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowsErrCall) DoAndReturn(f func() error) *MockRowsErrCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Next mocks base method.
func (m *MockRows) Next() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockRowsMockRecorder) Next() *MockRowsNextCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockRows)(nil).Next))
	return &MockRowsNextCall{Call: call}
}

// MockRowsNextCall wrap *gomock.Call
type MockRowsNextCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowsNextCall) Return(arg0 bool) *MockRowsNextCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowsNextCall) Do(f func() bool) *MockRowsNextCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowsNextCall) DoAndReturn(f func() bool) *MockRowsNextCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Scan mocks base method.
func (m *MockRows) Scan(arg0 ...any) error {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockRowsMockRecorder) Scan(arg0 ...any) *MockRowsScanCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockRows)(nil).Scan), arg0...)
	return &MockRowsScanCall{Call: call}
}

// MockRowsScanCall wrap *gomock.Call
type MockRowsScanCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockRowsScanCall) Return(arg0 error) *MockRowsScanCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockRowsScanCall) Do(f func(...any) error) *MockRowsScanCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockRowsScanCall) DoAndReturn(f func(...any) error) *MockRowsScanCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockTransaction is a mock of Transaction interface.
type MockTransaction struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionMockRecorder
}

// MockTransactionMockRecorder is the mock recorder for MockTransaction.
type MockTransactionMockRecorder struct {
	mock *MockTransaction
}

// NewMockTransaction creates a new mock instance.
func NewMockTransaction(ctrl *gomock.Controller) *MockTransaction {
	mock := &MockTransaction{ctrl: ctrl}
	mock.recorder = &MockTransactionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransaction) EXPECT() *MockTransactionMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockTransaction) Begin(arg0 context.Context) (database.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", arg0)
	ret0, _ := ret[0].(database.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockTransactionMockRecorder) Begin(arg0 any) *MockTransactionBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockTransaction)(nil).Begin), arg0)
	return &MockTransactionBeginCall{Call: call}
}

// MockTransactionBeginCall wrap *gomock.Call
type MockTransactionBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionBeginCall) Return(arg0 database.Transaction, arg1 error) *MockTransactionBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionBeginCall) Do(f func(context.Context) (database.Transaction, error)) *MockTransactionBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionBeginCall) DoAndReturn(f func(context.Context) (database.Transaction, error)) *MockTransactionBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockTransaction) Commit(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockTransactionMockRecorder) Commit(arg0 any) *MockTransactionCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTransaction)(nil).Commit), arg0)
	return &MockTransactionCommitCall{Call: call}
}

// MockTransactionCommitCall wrap *gomock.Call
type MockTransactionCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionCommitCall) Return(arg0 error) *MockTransactionCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionCommitCall) Do(f func(context.Context) error) *MockTransactionCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionCommitCall) DoAndReturn(f func(context.Context) error) *MockTransactionCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// End mocks base method.
func (m *MockTransaction) End(arg0 context.Context, arg1 error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "End", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// End indicates an expected call of End.
func (mr *MockTransactionMockRecorder) End(arg0, arg1 any) *MockTransactionEndCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "End", reflect.TypeOf((*MockTransaction)(nil).End), arg0, arg1)
	return &MockTransactionEndCall{Call: call}
}

// MockTransactionEndCall wrap *gomock.Call
type MockTransactionEndCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionEndCall) Return(arg0 error) *MockTransactionEndCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionEndCall) Do(f func(context.Context, error) error) *MockTransactionEndCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionEndCall) DoAndReturn(f func(context.Context, error) error) *MockTransactionEndCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Exec mocks base method.
func (m *MockTransaction) Exec(arg0 context.Context, arg1 string, arg2 ...any) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockTransactionMockRecorder) Exec(arg0, arg1 any, arg2 ...any) *MockTransactionExecCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockTransaction)(nil).Exec), varargs...)
	return &MockTransactionExecCall{Call: call}
}

// MockTransactionExecCall wrap *gomock.Call
type MockTransactionExecCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionExecCall) Return(arg0 int64, arg1 error) *MockTransactionExecCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionExecCall) Do(f func(context.Context, string, ...any) (int64, error)) *MockTransactionExecCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionExecCall) DoAndReturn(f func(context.Context, string, ...any) (int64, error)) *MockTransactionExecCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Query mocks base method.
func (m *MockTransaction) Query(arg0 context.Context, arg1 string, arg2 ...any) (database.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(database.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockTransactionMockRecorder) Query(arg0, arg1 any, arg2 ...any) *MockTransactionQueryCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockTransaction)(nil).Query), varargs...)
	return &MockTransactionQueryCall{Call: call}
}

// MockTransactionQueryCall wrap *gomock.Call
type MockTransactionQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionQueryCall) Return(arg0 database.Rows, arg1 error) *MockTransactionQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionQueryCall) Do(f func(context.Context, string, ...any) (database.Rows, error)) *MockTransactionQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionQueryCall) DoAndReturn(f func(context.Context, string, ...any) (database.Rows, error)) *MockTransactionQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// QueryRow mocks base method.
func (m *MockTransaction) QueryRow(arg0 context.Context, arg1 string, arg2 ...any) database.Row {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(database.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockTransactionMockRecorder) QueryRow(arg0, arg1 any, arg2 ...any) *MockTransactionQueryRowCall {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockTransaction)(nil).QueryRow), varargs...)
	return &MockTransactionQueryRowCall{Call: call}
}

// MockTransactionQueryRowCall wrap *gomock.Call
type MockTransactionQueryRowCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionQueryRowCall) Return(arg0 database.Row) *MockTransactionQueryRowCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionQueryRowCall) Do(f func(context.Context, string, ...any) database.Row) *MockTransactionQueryRowCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionQueryRowCall) DoAndReturn(f func(context.Context, string, ...any) database.Row) *MockTransactionQueryRowCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Rollback mocks base method.
func (m *MockTransaction) Rollback(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTransactionMockRecorder) Rollback(arg0 any) *MockTransactionRollbackCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTransaction)(nil).Rollback), arg0)
	return &MockTransactionRollbackCall{Call: call}
}

// MockTransactionRollbackCall wrap *gomock.Call
type MockTransactionRollbackCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTransactionRollbackCall) Return(arg0 error) *MockTransactionRollbackCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTransactionRollbackCall) Do(f func(context.Context) error) *MockTransactionRollbackCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTransactionRollbackCall) DoAndReturn(f func(context.Context) error) *MockTransactionRollbackCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
