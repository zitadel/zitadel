// Code generated by "enumer -type NumberOperation,TextOperation,BytesOperation -linecomment -output ./operators_enumer.go"; DO NOT EDIT.

package database

import (
	"fmt"
	"strings"
)

const _NumberOperationName = "=<><<=>>="

var _NumberOperationIndex = [...]uint8{0, 1, 3, 4, 6, 7, 9}

const _NumberOperationLowerName = "=<><<=>>="

func (i NumberOperation) String() string {
	i -= 1
	if i >= NumberOperation(len(_NumberOperationIndex)-1) {
		return fmt.Sprintf("NumberOperation(%d)", i+1)
	}
	return _NumberOperationName[_NumberOperationIndex[i]:_NumberOperationIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _NumberOperationNoOp() {
	var x [1]struct{}
	_ = x[NumberOperationEqual-(1)]
	_ = x[NumberOperationNotEqual-(2)]
	_ = x[NumberOperationLessThan-(3)]
	_ = x[NumberOperationAtLeast-(4)]
	_ = x[NumberOperationGreaterThan-(5)]
	_ = x[NumberOperationAtMost-(6)]
}

var _NumberOperationValues = []NumberOperation{NumberOperationEqual, NumberOperationNotEqual, NumberOperationLessThan, NumberOperationAtLeast, NumberOperationGreaterThan, NumberOperationAtMost}

var _NumberOperationNameToValueMap = map[string]NumberOperation{
	_NumberOperationName[0:1]:      NumberOperationEqual,
	_NumberOperationLowerName[0:1]: NumberOperationEqual,
	_NumberOperationName[1:3]:      NumberOperationNotEqual,
	_NumberOperationLowerName[1:3]: NumberOperationNotEqual,
	_NumberOperationName[3:4]:      NumberOperationLessThan,
	_NumberOperationLowerName[3:4]: NumberOperationLessThan,
	_NumberOperationName[4:6]:      NumberOperationAtLeast,
	_NumberOperationLowerName[4:6]: NumberOperationAtLeast,
	_NumberOperationName[6:7]:      NumberOperationGreaterThan,
	_NumberOperationLowerName[6:7]: NumberOperationGreaterThan,
	_NumberOperationName[7:9]:      NumberOperationAtMost,
	_NumberOperationLowerName[7:9]: NumberOperationAtMost,
}

var _NumberOperationNames = []string{
	_NumberOperationName[0:1],
	_NumberOperationName[1:3],
	_NumberOperationName[3:4],
	_NumberOperationName[4:6],
	_NumberOperationName[6:7],
	_NumberOperationName[7:9],
}

// NumberOperationString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func NumberOperationString(s string) (NumberOperation, error) {
	if val, ok := _NumberOperationNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _NumberOperationNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to NumberOperation values", s)
}

// NumberOperationValues returns all values of the enum
func NumberOperationValues() []NumberOperation {
	return _NumberOperationValues
}

// NumberOperationStrings returns a slice of all String values of the enum
func NumberOperationStrings() []string {
	strs := make([]string, len(_NumberOperationNames))
	copy(strs, _NumberOperationNames)
	return strs
}

// IsANumberOperation returns "true" if the value is listed in the enum definition. "false" otherwise
func (i NumberOperation) IsANumberOperation() bool {
	for _, v := range _NumberOperationValues {
		if i == v {
			return true
		}
	}
	return false
}

const _TextOperationName = "=<>LIKE"

var _TextOperationIndex = [...]uint8{0, 1, 3, 7}

const _TextOperationLowerName = "=<>like"

func (i TextOperation) String() string {
	i -= 1
	if i >= TextOperation(len(_TextOperationIndex)-1) {
		return fmt.Sprintf("TextOperation(%d)", i+1)
	}
	return _TextOperationName[_TextOperationIndex[i]:_TextOperationIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _TextOperationNoOp() {
	var x [1]struct{}
	_ = x[TextOperationEqual-(1)]
	_ = x[TextOperationNotEqual-(2)]
	_ = x[TextOperationStartsWith-(3)]
}

var _TextOperationValues = []TextOperation{TextOperationEqual, TextOperationNotEqual, TextOperationStartsWith}

var _TextOperationNameToValueMap = map[string]TextOperation{
	_TextOperationName[0:1]:      TextOperationEqual,
	_TextOperationLowerName[0:1]: TextOperationEqual,
	_TextOperationName[1:3]:      TextOperationNotEqual,
	_TextOperationLowerName[1:3]: TextOperationNotEqual,
	_TextOperationName[3:7]:      TextOperationStartsWith,
	_TextOperationLowerName[3:7]: TextOperationStartsWith,
}

var _TextOperationNames = []string{
	_TextOperationName[0:1],
	_TextOperationName[1:3],
	_TextOperationName[3:7],
}

// TextOperationString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func TextOperationString(s string) (TextOperation, error) {
	if val, ok := _TextOperationNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _TextOperationNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to TextOperation values", s)
}

// TextOperationValues returns all values of the enum
func TextOperationValues() []TextOperation {
	return _TextOperationValues
}

// TextOperationStrings returns a slice of all String values of the enum
func TextOperationStrings() []string {
	strs := make([]string, len(_TextOperationNames))
	copy(strs, _TextOperationNames)
	return strs
}

// IsATextOperation returns "true" if the value is listed in the enum definition. "false" otherwise
func (i TextOperation) IsATextOperation() bool {
	for _, v := range _TextOperationValues {
		if i == v {
			return true
		}
	}
	return false
}

const _BytesOperationName = "=<>"

var _BytesOperationIndex = [...]uint8{0, 1, 3}

const _BytesOperationLowerName = "=<>"

func (i BytesOperation) String() string {
	i -= 1
	if i >= BytesOperation(len(_BytesOperationIndex)-1) {
		return fmt.Sprintf("BytesOperation(%d)", i+1)
	}
	return _BytesOperationName[_BytesOperationIndex[i]:_BytesOperationIndex[i+1]]
}

// An "invalid array index" compiler error signifies that the constant values have changed.
// Re-run the stringer command to generate them again.
func _BytesOperationNoOp() {
	var x [1]struct{}
	_ = x[BytesOperationEqual-(1)]
	_ = x[BytesOperationNotEqual-(2)]
}

var _BytesOperationValues = []BytesOperation{BytesOperationEqual, BytesOperationNotEqual}

var _BytesOperationNameToValueMap = map[string]BytesOperation{
	_BytesOperationName[0:1]:      BytesOperationEqual,
	_BytesOperationLowerName[0:1]: BytesOperationEqual,
	_BytesOperationName[1:3]:      BytesOperationNotEqual,
	_BytesOperationLowerName[1:3]: BytesOperationNotEqual,
}

var _BytesOperationNames = []string{
	_BytesOperationName[0:1],
	_BytesOperationName[1:3],
}

// BytesOperationString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func BytesOperationString(s string) (BytesOperation, error) {
	if val, ok := _BytesOperationNameToValueMap[s]; ok {
		return val, nil
	}

	if val, ok := _BytesOperationNameToValueMap[strings.ToLower(s)]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to BytesOperation values", s)
}

// BytesOperationValues returns all values of the enum
func BytesOperationValues() []BytesOperation {
	return _BytesOperationValues
}

// BytesOperationStrings returns a slice of all String values of the enum
func BytesOperationStrings() []string {
	strs := make([]string, len(_BytesOperationNames))
	copy(strs, _BytesOperationNames)
	return strs
}

// IsABytesOperation returns "true" if the value is listed in the enum definition. "false" otherwise
func (i BytesOperation) IsABytesOperation() bool {
	for _, v := range _BytesOperationValues {
		if i == v {
			return true
		}
	}
	return false
}
