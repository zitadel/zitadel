/**
 * generate-descriptions.mts
 *
 * Generates SEO meta description frontmatter for MDX docs pages that are missing one,
 * using an OpenAI-compatible LLM endpoint (local or remote).
 *
 * Usage:
 *   node --experimental-strip-types apps/docs/scripts/generate-descriptions.mts [options]
 *
 * Options:
 *   --base-url <url>    LLM server base URL  (default: http://127.0.0.1:1234)
 *   --model <id>        Model identifier     (default: qwen2.5-14b-instruct)
 *   --dry-run           Preview without writing files
 *   --force             Re-generate even if a description already exists
 *   --file <path>       Process a single file only (relative to content/)
 *   --delay <ms>        Delay between API calls in ms (default: 200)
 *   --start-from <n>    Skip the first N eligible files (resume after interruption)
 *   --limit <n>         Process at most N files then stop
 *
 * Excluded content (generated / versioned — must not be edited):
 *   - content/reference/          auto-generated REST/gRPC API reference (generate-api-reference target)
 *   - content/v<N.M>/             versioned doc snapshots fetched at build time (fetch-remote-content target)
 *   - content/apis/proto/         buf-generated protobuf docs (gitignored)
 *   - any index.mdx              all index pages are generated by the generate-index-pages target
 *   - files starting with _       MDX partials (not navigable pages)
 */

import { writeFileSync } from 'node:fs';
import { readFile } from 'node:fs/promises';
import { relative, basename, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { parseArgs } from 'node:util';
import fg from 'fast-glob';

// ---------------------------------------------------------------------------
// Exclusion rules for generated / versioned / partial content.
// ---------------------------------------------------------------------------

/** Top-level directory names that are entirely auto-generated. */
const EXCLUDED_DIR_PREFIXES = [
  'reference', // generate-api-reference target → content/reference/api/
];

/** Top-level directory patterns that are auto-generated or fetched. */
const EXCLUDED_DIR_PATTERNS = [
  /^v\d/, // versioned snapshots: v4.10, v4.11, … (fetch-remote-content target)
];

/** Path prefixes (relative to content/) that are entirely auto-generated. */
const EXCLUDED_PATH_PREFIXES = [
  'apis/proto/', // buf-generated protobuf docs — gitignored, not committed
];

function isExcluded(contentRelPath: string): boolean {
  if (basename(contentRelPath) === 'index.mdx') return true;

  const first = contentRelPath.split('/')[0];
  if (EXCLUDED_DIR_PREFIXES.includes(first)) return true;
  if (EXCLUDED_DIR_PATTERNS.some((re) => re.test(first))) return true;
  if (EXCLUDED_PATH_PREFIXES.some((p) => contentRelPath.startsWith(p))) return true;

  return false;
}

// ---------------------------------------------------------------------------
// Content-category classification (4 broad categories)
// ---------------------------------------------------------------------------

type ContentCategory = 'reference' | 'guide' | 'concept' | 'other';

/** Map path prefixes to broad categories. Order matters — first match wins. */
const CATEGORY_RULES: Array<{ prefix: string; category: ContentCategory }> = [
  // Reference: API specs, protocol docs, benchmarks
  { prefix: 'apis/benchmarks/', category: 'reference' },
  { prefix: 'apis/actions/',    category: 'guide' },      // cookbook/how-to, not spec
  { prefix: 'apis/',            category: 'reference' },

  // Guide: how-tos, quickstarts, deployment, operations, SDK examples
  { prefix: 'guides/',          category: 'guide' },
  { prefix: 'sdk-examples/',    category: 'guide' },
  { prefix: 'examples/',        category: 'guide' },
  { prefix: 'self-hosting/',    category: 'guide' },

  // Concept: architecture, IAM model, product/roadmap
  { prefix: 'concepts/',        category: 'concept' },
  { prefix: 'product/',         category: 'concept' },

  // Other: legal, advisories, everything else
  { prefix: 'legal/',           category: 'other' },
  { prefix: 'support/advisory/', category: 'other' },
];

function detectCategory(relPath: string): ContentCategory {
  for (const { prefix, category } of CATEGORY_RULES) {
    if (relPath.startsWith(prefix)) return category;
  }
  return 'other';
}

/** Per-category prompt configuration. */
const CATEGORY_PROMPTS: Record<ContentCategory, { focusClause: string; pageKind: string }> = {
  reference: {
    pageKind: 'API or protocol reference page',
    focusClause:
      'Name the exact protocol, API, or benchmark scenario. ' +
      'State what a developer can achieve and name the protocol-level concepts affected (claims, tokens, assertions, attributes, responses, scopes). ' +
      'Do NOT include internal method names (e.g. setClaim, getUser, setMetadata) — describe outcomes, not API calls. ' +
      'Specify the subject performing the action (e.g., "OAuth clients", "service users") — do not use generic "authentication" without stating who or what authenticates.',
  },
  guide: {
    pageKind: 'how-to or integration guide',
    focusClause:
      'Identify the specific task or problem being solved. ' +
      'Name the exact tools, frameworks, or ZITADEL features involved — if the page belongs to a named ZITADEL feature (e.g., Actions, Console, Login), include that feature name. ' +
      'If a specific tech stack or platform is mentioned, include it. ' +
      'If the page is a collection of code examples, say so — include the words "code examples" in the description. ' +
      'Do NOT include internal method names, trigger names, or lifecycle phases — describe what the page enables, not how the internals work.',
  },
  concept: {
    pageKind: 'conceptual or architectural documentation page',
    focusClause:
      'Open with the concept or feature name. ' +
      'Define what it is and why it matters within the ZITADEL IAM model. ' +
      'Use architectural or domain-specific terms from the content.',
  },
  other: {
    pageKind: 'documentation page',
    focusClause:
      'Identify the main topic and state the key information this page provides. ' +
      'For legal documents, do not include "ZITADEL". ' +
      'For advisories, include the advisory ID and affected versions if present.',
  },
};

// ---------------------------------------------------------------------------
// CLI argument parsing
// ---------------------------------------------------------------------------

const { values: _args } = parseArgs({
  args: process.argv.slice(2),
  options: {
    'base-url':   { type: 'string',  default: 'http://127.0.0.1:1234' },
    model:        { type: 'string',  default: 'Qwen2.5-72B-Instruct-GGUF' },
    'dry-run':    { type: 'boolean', default: false },
    force:        { type: 'boolean', default: false },
    file:         { type: 'string' },
    delay:        { type: 'string',  default: '200' },
    'start-from': { type: 'string',  default: '0' },
    limit:        { type: 'string' },
  },
});

const BASE_URL    = _args['base-url'] as string;
const MODEL       = _args.model as string;
const DRY_RUN     = _args['dry-run'] as boolean;
const FORCE       = _args['force'] as boolean;
const SINGLE_FILE = _args.file as string | undefined;
const DELAY_MS    = Number(_args.delay);
const START_FROM  = Number(_args['start-from']);
const LIMIT       = _args.limit !== undefined ? Number(_args.limit) : Infinity;

if (isNaN(DELAY_MS))   { console.error('Error: --delay must be a number'); process.exit(1); }
if (isNaN(START_FROM)) { console.error('Error: --start-from must be a number'); process.exit(1); }
if (_args.limit !== undefined && isNaN(LIMIT)) { console.error('Error: --limit must be a number'); process.exit(1); }

const CONTENT_DIR = fileURLToPath(new URL('../content', import.meta.url));

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Recursively collect all .mdx file paths under a directory. */
async function globMdx(dir: string): Promise<string[]> {
  return fg(['**/*.mdx'], { cwd: dir, absolute: true, dot: false, followSymbolicLinks: false });
}

/**
 * Parse YAML frontmatter from an MDX string.
 */
function parseFrontmatter(content: string): {
  fm: Record<string, string>;
  rawFm: string;
  body: string;
} {
  const { hasFm, fmRaw, body } = splitFrontmatter(content);
  if (!hasFm) return { fm: {}, rawFm: '', body: content };

  const fm: Record<string, string> = {};
  for (const line of fmRaw.split('\n')) {
    const kv = line.match(/^(\w[\w_-]*):\s*(.*)$/);
    if (kv) fm[kv[1]] = kv[2].trim().replace(/^["']|["']$/g, '');
  }

  return { fm, rawFm: fmRaw, body };
}

/**
 * Returns true when the raw frontmatter block contains a `description` key
 * with a non-empty, non-trivial value.
 */
function hasRealDescription(rawFm: string): boolean {
  const lines = rawFm.split('\n');
  const idx = lines.findIndex((l) => /^description:\s*/.test(l));
  if (idx === -1) return false;

  const first = lines[idx].replace(/^description:\s*/, '').trim();
  if (first && !/^[>|][+-]?$/.test(first) && !['""', "''"].includes(first)) return true;

  for (let i = idx + 1; i < lines.length; i++) {
    const l = lines[i];
    if (/^\S/.test(l)) break;
    if (l.trim().length > 0) return true;
  }

  return false;
}

/**
 * Build a rich context string for the LLM by sending up to ~8000 chars of page content.
 *
 * Strategy:
 *   1. Extract the introductory sentence/paragraph and label it prominently.
 *   2. Extract all ## / ### headings as a full document outline.
 *   3. Send cleaned body prose up to 8000 chars with noise stripped:
 *      - imports, code fences, empty HTML detail/summary shells,
 *      - raw MDX/JSX expressions, markdown link URLs (keep display text),
 *      - markdown table alignment rows (keep header + data rows as text).
 */
function extractContext(body: string): string {
  const maxBodyChars = 8000;

  let cleaned = body
    // Strip imports
    .replace(/^import\s.*$/gm, '')
    // Strip code fence bodies entirely (method names are
    // extracted separately by extractMethodNames, so we don't need hints here)
    .replace(/```[^\n]*\n[\s\S]*?```/g, '')
    // Strip empty HTML detail/summary shells left after code fence removal
    .replace(/<details[^>]*>\s*<\/details>/gi, '')
    .replace(/<details[^>]*>\s*<summary[^>]*>.*?<\/summary>\s*<\/details>/gi, '')
    .replace(/<\/?(?:details|summary)[^>]*>/gi, '')
    // Strip raw MDX/JSX expressions (e.g. {props.summary ? props.summary : 'Code example'})
    .replace(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g, '')
    // Simplify markdown links: [display text](url) → display text
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
    // Simplify markdown table alignment rows: |:---|:---|
    .replace(/^\|[\s:|-]+\|$/gm, '')
    // Strip table pipe formatting but keep cell content (only for actual table rows with ≥2 pipes)
    .replace(/^(\|.*\|.*\|.*)$/gm, (_match, row: string) => row.replace(/^\|\s*/, '').replace(/\s*\|$/, ''))
    // Collapse triple+ newlines
    .replace(/\n{3,}/g, '\n\n')
    .trim();

  // Extract the introductory paragraph (first non-empty, non-heading block)
  let intro = '';
  const introMatch = cleaned.match(/^([^#\n][^\n]+(?:\n[^#\n][^\n]+)*)/);
  if (introMatch) {
    const candidate = introMatch[1].trim();
    // Only use if it's real prose (not just a link or very short)
    if (candidate.length > 30) {
      intro = candidate;
    }
  }

  // Build full heading outline
  const headings: string[] = [];
  for (const line of cleaned.split('\n')) {
    const m = line.match(/^\s*(#{2,3})\s+(.+?)\s*$/);
    if (m) {
      const indent = m[1].length === 3 ? '  -' : '-';
      headings.push(`${indent} ${m[2]}`);
    }
  }
  const outline =
    headings.length > 0
      ? `[DOCUMENT OUTLINE]\n${headings.join('\n')}\n\n`
      : '';

  // Send prose up to the budget — simple top-slice
  let prose = cleaned.slice(0, maxBodyChars).trim();
  if (cleaned.length > maxBodyChars) {
    // Cut at last word boundary to avoid mid-word truncation
    const lastSpace = prose.lastIndexOf(' ');
    if (lastSpace > maxBodyChars * 0.8) prose = prose.slice(0, lastSpace);
    prose += '\n[…truncated]';
  }

  let result = '';
  if (intro) result += `[INTRODUCTORY SENTENCE]\n${intro}\n\n`;
  result += outline;
  if (prose) result += `[PAGE CONTENT]\n${prose}`;
  return result.trim();
}

/**
 * Sanitize LLM output: strip formatting artifacts, normalize casing, enforce length cap.
 */
function sanitizeDescription(text: string): string {
  let clean = text.trim();

  // Strip surrounding quotes
  clean = clean.replace(/^["']|["']$/g, '').trim();

  // Strip rogue markdown (bold, italic, inline code)
  clean = clean.replace(/[*`_]/g, '');

  // Replace vague "manipulating users" with specific domain nouns
  clean = clean.replace(/manipulat(e|ing) users/gi, 'user roles, metadata, and attributes');

  // Normalize industry-standard OAuth/OIDC/SAML terminology
  clean = clean.replace(/\bidtoken\b/gi, 'ID token');
  clean = clean.replace(/\baccesstoken\b/gi, 'access token');
  clean = clean.replace(/\brefreshtoken\b/gi, 'refresh token');
  clean = clean.replace(/\bSAMLResponse\b/g, 'SAML response');

  // Strip leaked internal method names (camelCase function calls)
  clean = clean.replace(/\b(setClaim|setCustomClaim|setCustomAttribute|getUser|getMetadata|setMetadata|appendLogIntoClaims|getUserGrants|getAction|setEmail|setPhone|getClaimsFromHeader)\b/g, '').trim();
  // Strip orphaned "methods"/"functions" words left after method name removal
  clean = clean.replace(/\b(methods?|functions?|function names?)\b/gi, '');
  // Strip internal lifecycle / trigger names
  clean = clean.replace(/\bPre\s+(SAMLResponse|SAML\s+response|Token|Access\s+Token|ID\s+Token)\s+(creation|introspection)\s*(flow|trigger)?/gi, (_m, entity: string, phase: string) => {
    const ent = entity.replace(/samlresponse/i, 'SAML response').replace(/token/i, 'token');
    return `before ${ent} ${phase}`;
  });
  clean = clean.replace(/\bPost\s+(Authentication|Creation)\s*(flow|trigger)?/gi, 'after $1');
  // Collapse double spaces, orphaned commas/conjunctions, and "with ,"-style debris
  clean = clean.replace(/,\s*,/g, ',').replace(/\s{2,}/g, ' ').replace(/\s+,/g, ',');
  clean = clean.replace(/\bwith\s*,?\s*(and\s*)?$/i, '').trim();
  clean = clean.replace(/,\s*(and\s*)?$/i, '').trim();

  // Strip banned openers the model sometimes ignores
  clean = clean.replace(/^(Use|Explore|Discover|Learn( how( to)?)?|This (page|guide|document|article)|ZITADEL (guides|helps|shows|describes|walks)( you| developers?)?( through| how)?)[:\s,]+/i, '').trim();
  // Re-capitalize first letter after stripping
  if (clean.length > 0) clean = clean[0].toUpperCase() + clean.slice(1);

  // Collapse newlines and whitespace runs
  clean = clean.replace(/\r?\n+/g, ' ').replace(/\s{2,}/g, ' ').trim();

  // Extract first sentence only (cut at ". " / "? " / "! " boundary)
  const sentEnd = clean.search(/[.?!]\s/);
  if (sentEnd !== -1) clean = clean.slice(0, sentEnd).trim();

  // Strip leading/trailing dashes, em-dashes, colons
  clean = clean.replace(/^[\s\-–—:]+/, '').replace(/[\s\-–—:]+$/, '').trim();

  // Remove trailing period
  clean = clean.replace(/\.$/, '');

  // Normalize ZITADEL casing
  clean = clean.replace(/\bzitadel\b/gi, 'ZITADEL');

  // Hard cap at 160 chars, cut at last whole word
  if (clean.length > 160) {
    const cut = clean.slice(0, 160);
    const lastSpace = cut.lastIndexOf(' ');
    clean = lastSpace > 40 ? cut.slice(0, lastSpace) : cut.trim();
    // Strip trailing punctuation after truncation
    clean = clean.replace(/[.!?:,\-–—]+$/, '').trim();
  }

  // Detect dangling fragments left after truncation (e.g. "functions like", "in the SAML")
  // If the description ends with a preposition, conjunction, article, or dangling word, trim it.
  const danglingPattern = /\s+(like|using|with|for|in|on|at|to|of|the|a|an|and|or|by|from|into|through|via|such|as|including|between|across|within|about|during|over|your|their|its|our|this|that|these|those)$/i;
  while (danglingPattern.test(clean)) {
    clean = clean.replace(danglingPattern, '').trim();
    clean = clean.replace(/[.!?:,\-–—]+$/, '').trim();
  }

  return clean;
}

/**
 * Slice content into its raw frontmatter and body parts.
 */
function splitFrontmatter(content: string): { hasFm: boolean; fmRaw: string; body: string } {
  const m = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/);
  if (!m) return { hasFm: false, fmRaw: '', body: content };
  return { hasFm: true, fmRaw: m[1], body: m[2] ?? '' };
}

/**
 * Inject or replace the `description` field inside the frontmatter block only.
 */
function injectDescription(content: string, description: string): string {
  const escaped = description.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  const { hasFm, fmRaw, body } = splitFrontmatter(content);

  const eol = content.includes('\r\n') ? '\r\n' : '\n';
  const lines = hasFm ? fmRaw.split('\n').map((l) => l.replace(/\r$/, '')) : [];

  const descIdx = lines.findIndex((l) => /^description:\s*/.test(l));
  if (descIdx !== -1) {
    // Replace existing — also remove any continuation lines (block scalar)
    lines[descIdx] = `description: "${escaped}"`;
    while (descIdx + 1 < lines.length && /^\s/.test(lines[descIdx + 1])) {
      lines.splice(descIdx + 1, 1);
    }
  } else {
    const titleIdx = lines.findIndex((l) => /^title:\s*/.test(l));
    if (titleIdx !== -1) {
      lines.splice(titleIdx + 1, 0, `description: "${escaped}"`);
    } else {
      lines.unshift(`description: "${escaped}"`);
    }
  }

  const fmBlock = `---${eol}${lines.join(eol)}${eol}---${eol}`;
  return hasFm ? fmBlock + body : fmBlock + content;
}

/**
 * Perform a chat completion call. Retries up to 3 times on network-level failures.
 */
async function callLLM(
  messages: Array<{ role: string; content: string }>,
  maxTokens = 200,
): Promise<string> {
  const MAX_ATTEMPTS = 3;
  let lastError: Error | undefined;

  for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60_000);
      let response: Response;
      try {
        response = await fetch(`${BASE_URL}/v1/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: MODEL,
            messages,
            max_tokens: maxTokens,
            temperature: 0.3,
            top_p: 0.9,
            stop: ['\n\n'],
          }),
          signal: controller.signal,
        });
      } finally {
        clearTimeout(timeoutId);
      }

      if (!response.ok) {
        const text = await response.text();
        if (response.status < 500) throw new Error(`LLM API error ${response.status}: ${text}`);
        throw new Error(`LLM server error ${response.status}: ${text}`);
      }

      const json = (await response.json()) as {
        choices: Array<{ message: { content: string } }>;
      };
      return json.choices?.[0]?.message?.content ?? '';
    } catch (err) {
      lastError = err as Error;
      if (attempt < MAX_ATTEMPTS) {
        const backoffMs = 500 * 2 ** (attempt - 1);
        await new Promise((r) => setTimeout(r, backoffMs));
      }
    }
  }

  throw lastError;
}

/**
 * Extract ## headings from body text (not ### or deeper).
 * Used to surface the major page sections explicitly in the user prompt.
 */
function extractMajorSections(body: string): string[] {
  const headings: string[] = [];
  for (const line of body.split('\n')) {
    const m = line.match(/^\s*##\s+(.+?)\s*$/);
    // Only match ## (not ### or deeper)
    if (m && !line.match(/^\s*###/)) headings.push(m[1]);
  }
  return headings;
}

/**
 * Extract API method / function names from body text.
 * Looks for patterns like `methodName(` or `api.v1.something.methodName(`.
 * Returns deduplicated list of short method names.
 */
function extractMethodNames(body: string): string[] {
  const methods = new Set<string>();
  // Match patterns like setClaim(, setCustomAttribute(, getMetadata(, appendLogIntoClaims(
  const re = /\b([a-z][a-zA-Z]+)\s*\(/g;
  let match: RegExpExecArray | null;
  while ((match = re.exec(body)) !== null) {
    const name = match[1];
    // Filter out common noise words, JS builtins, and generic identifiers
    const NOISE = new Set([
      // JS keywords & builtins
      'function', 'import', 'require', 'return', 'export', 'const', 'console',
      'typeof', 'async', 'await', 'yield', 'delete', 'throw', 'catch',
      'undefined', 'null', 'true', 'false', 'this', 'super', 'class',
      // Common JS/TS methods & globals
      'forEach', 'push', 'filter', 'splice', 'slice', 'reduce', 'trim',
      'join', 'split', 'replace', 'match', 'test', 'indexOf', 'lastIndexOf',
      'find', 'findIndex', 'some', 'every', 'includes', 'concat', 'sort',
      'reverse', 'keys', 'values', 'entries', 'from', 'parse', 'stringify',
      'toString', 'valueOf', 'hasOwnProperty', 'apply', 'call', 'bind',
      'then', 'resolve', 'reject', 'finally',
      'fetch', 'abort', 'clearTimeout', 'setTimeout', 'setInterval',
      'warn', 'error', 'info', 'debug', 'trace', 'assert',
      'JSON', 'Math', 'Date', 'Array', 'Object', 'String', 'Number',
      // React / MDX / framework noise
      'props', 'details', 'summary', 'useState', 'useEffect', 'useRef',
      'useCallback', 'useMemo', 'useContext', 'createElement',
      // Generic identifiers that are not API-specific
      'name', 'data', 'type', 'value', 'result', 'response', 'request',
      'callback', 'handler', 'config', 'options', 'params', 'args',
      'item', 'items', 'list', 'next', 'prev', 'emit', 'send',
      'write', 'read', 'open', 'close', 'init', 'start', 'stop',
      'encode', 'decode', 'length', 'size', 'count', 'index',
    ]);
    if (name.length >= 4 && !NOISE.has(name)) {
      methods.add(name);
    }
  }
  return [...methods];
}

/**
 * Generate a meta description for a single page.
 * One LLM call — no retries for content quality.
 */
async function generateDescription(
  title: string,
  context: string,
  category: ContentCategory,
  body: string,
  relPath: string,
  fm: Record<string, string> = {},
): Promise<string> {
  const { focusClause, pageKind } = CATEGORY_PROMPTS[category];

  const isLegal = category === 'other' && /\blegal\b/i.test(title);
  const brandRule = isLegal
    ? 'Do not include "ZITADEL" in the description.'
    : 'Include "ZITADEL" exactly once.';

  // Extract top-level sections to surface them explicitly in the prompt.
  const majorSections = extractMajorSections(body);
  let breadthRule = '';
  if (majorSections.length >= 2) {
    breadthRule =
      `CRITICAL: This page covers ${majorSections.length} major topics: ${majorSections.join(', ')}. ` +
      'Your description MUST reflect this breadth — do NOT focus only on the first topic. ' +
      'Mention at least 2–3 of these topics in a single flowing sentence.\n';
  }

  const systemPrompt =
    'You write SEO meta descriptions for ZITADEL technical documentation.\n' +
    'Output ONLY the description text — no labels, no quotes, no markdown.\n' +
    '\n' +
    '## FORMAT RULES\n' +
    'Exactly ONE sentence, plain text, 100–150 characters. Never exceed 155.\n' +
    `${brandRule}\n` +
    '\n' +
    '## SENTENCE STRUCTURE\n' +
    'Start with a concrete noun, feature name, or action verb from the page — NEVER with filler openers.\n' +
    'BANNED first words: "Use", "Explore", "Discover", "Learn", "This page", "This guide", "ZITADEL guides", "ZITADEL helps", "ZITADEL shows", "ZITADEL describes".\n' +
    'Always specify the actor or subject: say "OAuth clients", "service users", "applications", or "administrators" — never leave "authentication" or "authorization" unqualified.\n' +
    'Name the primary protocol or entity (OIDC, SAML, OAuth, tokens, claims) within the first 60 characters.\n' +
    'Prefer terms searchers use (claims, attributes, roles, tokens) over internal terms (parameters, flows, triggers).\n' +
    'Use industry-standard terminology: "ID token" not "idtoken", "access token" not "accesstoken", "refresh token" not "refreshtoken", "SAML response" not "SAMLResponse", "userinfo" not "user info".\n' +
    'BANNED PHRASES: Never write "manipulating users" or "manipulate users" — instead name what is changed: "user roles, metadata, and attributes" or "user roles and email verification".\n' +
    'Prefer specific domain nouns (roles, metadata, attributes, claims) over vague action verbs (manipulating, managing, handling, processing).\n' +
    'NEVER include internal method names (setClaim, getUser, setMetadata, appendLogIntoClaims, setCustomAttribute, etc.) in the description — describe outcomes and protocol-level concepts instead.\n' +
    'NEVER include internal lifecycle or trigger names ("Pre SAMLResponse creation", "Pre Token creation flow", "Post Authentication") — use user-facing language instead ("before the response is returned", "during token creation").\n' +
    'Describe WHAT the page enables and WHY, not HOW the internal machinery works.\n' +
    'End with a concrete noun or specific outcome — NEVER with vague words like "management", "workflows", "and more", "solutions", or "tasks".\n' +
    'Prefer stating WHERE something applies (endpoints, flows, scopes) or WHAT problem is solved over HOW bytes are formatted (headers, payloads, encodings).\n' +
    'Do not end with low-level transport details like header names or encoding schemes.\n' +
    '\n' +
    '## GOOD EXAMPLES (imitate these patterns)\n' +
    '- "Add custom claims to ZITADEL ID tokens and access tokens during token creation for identity enrichment"\n' +
    '- "ZITADEL Personal Access Tokens let service users authenticate for API calls without interactive login"\n' +
    '- "Mirror events between ZITADEL instances using the cockroach and postgres export commands"\n' +
    '- "Authenticate OAuth clients in ZITADEL using Client Secret Basic or private key JWT for token and introspection endpoints"\n' +
    '\n' +
    '## BAD EXAMPLES (never produce these)\n' +
    '- "Explore ZITADEL features for managing authentication" ← starts with Explore, too vague\n' +
    '- "ZITADEL guides you through configuring session parameters" ← starts with ZITADEL guides\n' +
    '- "Learn how to customize attributes before they are set in the" ← truncated, starts with Learn how\n' +
    '- "Configure token creation with parameters for userinfo endpoints" ← uses internal term "parameters" instead of "claims"\n' +
    '- "Use Client Secret Basic or JWT with Private Key for secure authentication in ZITADEL" ← starts with Use, ambiguous subject, missing endpoint context\n' +
    '- "ZITADEL Actions for manipulating users and customizing responses" ← "manipulating users" is vague; say "user roles, metadata, and attributes" instead\n' +
    '- "Customize SAML response attributes using ZITADEL\'s Pre SAML response creation flow with getUser and setCustomAttribute" ← includes internal lifecycle name and method names; say "Customize SAML response attributes in ZITADEL before the response is returned" instead\n' +
    '\n' +
    '## ACCURACY RULES\n' +
    'Closely paraphrase the page\'s own introductory sentence — do not reinterpret or generalize it.\n' +
    'Use only domain-level terms and facts from the page content — never copy internal method names, trigger names, flow IDs, or API IDs into the description.\n' +
    'Write for search engine users, not API consumers — abstract implementation details into user-facing outcomes.\n' +
    'Do NOT invent versions, feature names, or specs not present in the content.\n' +
    `${breadthRule}` +
    '\n' +
    focusClause;

  // Surface API method names as background context (the model must NOT copy them into the description).
  const methodNames = extractMethodNames(body);
  let methodHint = '';
  if (methodNames.length > 0) {
    methodHint = `\n[INTERNAL METHODS — for understanding only, do NOT include in description]: ${methodNames.join(', ')}\n`;
  }

  // Surface SDK-example frontmatter when available
  let sdkHint = '';
  if (relPath.startsWith('sdk-examples/')) {
    const parts: string[] = [];
    if (fm['auth_library']) parts.push(`Auth library: ${fm['auth_library']}`);
    if (fm['auth_flow']) parts.push(`Auth flow: ${fm['auth_flow']}`);
    if (fm['status']) parts.push(`Status: ${fm['status']}`);
    if (parts.length > 0) sdkHint = `\n[SDK METADATA]: ${parts.join(' | ')}\n`;
  }

  const userPrompt =
    `Page kind: ${pageKind}\n` +
    `Path: ${relPath}\n` +
    `Title: ${title}\n` +
    `${methodHint}` +
    `${sdkHint}\n` +
    `${context}`;

  const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ];

  const raw = await callLLM(messages);
  return sanitizeDescription(raw);
}

/** Sleep helper. */
const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main() {
  console.log(`LLM endpoint : ${BASE_URL}`);
  console.log(`Model        : ${MODEL}`);
  console.log(`Dry run      : ${DRY_RUN}`);
  console.log(`Force        : ${FORCE}`);
  console.log(`Delay        : ${DELAY_MS}ms`);
  console.log(`Excluded     : reference/, v*/, apis/proto/, **/index.mdx\n`);

  // Build file list
  let files: string[];
  if (SINGLE_FILE) {
    const resolved = resolve(CONTENT_DIR, SINGLE_FILE);
    const rel = relative(CONTENT_DIR, resolved);
    if (rel.startsWith('..')) {
      console.error(`Error: --file path escapes the content directory: ${SINGLE_FILE}`);
      process.exit(1);
    }
    files = [resolved];
  } else {
    const all = await globMdx(CONTENT_DIR);
    files = all.filter((f) => {
      const rel = relative(CONTENT_DIR, f);
      if (basename(f).startsWith('_')) return false;
      if (isExcluded(rel)) return false;
      return true;
    });
    files.sort();
  }

  // Read and filter eligible files
  type EligibleFile = { path: string; relPath: string; content: string; fm: Record<string, string>; body: string };
  const eligible: EligibleFile[] = [];
  for (const f of files) {
    const content = await readFile(f, 'utf-8');
    const { fm, rawFm, body } = parseFrontmatter(content);
    if (FORCE || !hasRealDescription(rawFm)) {
      eligible.push({ path: f, relPath: relative(CONTENT_DIR, f), content, fm, body });
    }
  }

  console.log(`Total non-generated MDX files : ${files.length}`);
  console.log(`Missing description           : ${eligible.length}`);
  if (START_FROM > 0) console.log(`Skipping first                : ${START_FROM}`);
  console.log('');

  const toProcess = eligible.slice(START_FROM, START_FROM + (isFinite(LIMIT) ? LIMIT : eligible.length));
  let succeeded = 0;
  let failed = 0;

  for (let i = 0; i < toProcess.length; i++) {
    const { path: filePath, relPath, content, fm, body } = toProcess[i];
    const globalIndex = START_FROM + i + 1;
    const progress = `[${globalIndex}/${eligible.length}]`;

    const title = fm['title'] ?? basename(filePath, '.mdx');
    const category = detectCategory(relPath);
    const context = extractContext(body);

    process.stdout.write(`${progress} [${category}] ${relPath} … `);

    try {
      const description = await generateDescription(title, context, category, body, relPath, fm);
      const charCount = description.length;

      if (charCount < 20) {
        console.log(`SKIPPED — description too short (${charCount} chars)`);
        failed++;
        continue;
      }

      if (DRY_RUN) {
        console.log(`\n  → (dry-run) ${description} [${charCount} chars]`);
      } else {
        const updated = injectDescription(content, description);
        if (updated !== content) writeFileSync(filePath, updated, 'utf-8');
        console.log(`done [${charCount} chars]`);
      }

      succeeded++;
    } catch (err) {
      console.log(`FAILED — ${(err as Error).message}`);
      failed++;
    }

    if (i < toProcess.length - 1) await sleep(DELAY_MS);
  }

  console.log(`\n✓ Succeeded: ${succeeded}  ✗ Failed: ${failed}`);
  if (failed > 0) process.exit(1);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
