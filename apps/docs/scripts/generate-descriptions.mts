/**
 * generate-descriptions.mts
 *
 * Generates SEO meta description frontmatter for MDX docs pages that are missing one,
 * using an OpenAI-compatible LLM endpoint (local or remote).
 *
 * Usage:
 *   node --experimental-strip-types apps/docs/scripts/generate-descriptions.mts [options]
 *
 * Options:
 *   --base-url <url>    LLM server base URL  (default: http://127.0.0.1:1234)
 *   --model <id>        Model identifier     (default: meta/llama-3.3-70b)
 *   --dry-run           Preview without writing files
 *   --force             Re-generate even if a description already exists
 *   --file <path>       Process a single file only (relative to content/)
 *   --delay <ms>        Delay between API calls in ms (default: 200)
 *   --start-from <n>    Skip the first N eligible files (resume after interruption)
 *   --limit <n>         Process at most N files then stop
 *
 * Excluded content (generated / versioned — must not be edited):
 *   - content/reference/          auto-generated REST/gRPC API reference (generate-api-reference target)
 *   - content/legal/              legal documents should not have AI-generated descriptions
 *   - content/v<N.M>/             versioned doc snapshots fetched at build time (fetch-remote-content target)
 *   - content/apis/proto/         buf-generated protobuf docs (gitignored)
 *   - any index.mdx              all index pages are generated by the generate-index-pages target
 *   - files starting with _       MDX partials (not navigable pages)
 */

import { writeFileSync } from 'node:fs';
import { readFile } from 'node:fs/promises';
import { relative, basename, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { parseArgs } from 'node:util';
import fg from 'fast-glob';

// ---------------------------------------------------------------------------
// Exclusion rules for generated / versioned / partial content.
// ---------------------------------------------------------------------------

/** Top-level directory names that are entirely auto-generated or should be excluded. */
const EXCLUDED_DIR_PREFIXES = [
  'reference', // generate-api-reference target → content/reference/api/
  'legal',     // legal documents should not have AI-generated descriptions
];

/** Top-level directory patterns that are auto-generated or fetched. */
const EXCLUDED_DIR_PATTERNS = [
  /^v\d/, // versioned snapshots: v4.10, v4.11, … (fetch-remote-content target)
];

/** Path prefixes (relative to content/) that are entirely auto-generated. */
const EXCLUDED_PATH_PREFIXES = [
  'apis/proto/', // buf-generated protobuf docs — gitignored, not committed
];

function isExcluded(contentRelPath: string): boolean {
  if (basename(contentRelPath) === 'index.mdx') return true;

  const first = contentRelPath.split('/')[0];
  if (EXCLUDED_DIR_PREFIXES.includes(first)) return true;
  if (EXCLUDED_DIR_PATTERNS.some((re) => re.test(first))) return true;
  if (EXCLUDED_PATH_PREFIXES.some((p) => contentRelPath.startsWith(p))) return true;

  return false;
}

// ---------------------------------------------------------------------------
// Content-category classification
// ---------------------------------------------------------------------------

type ContentCategory = 'reference' | 'guide' | 'sdk-example' | 'concept' | 'advisory' | 'self-hosting' | 'other';

/** Map path prefixes to broad categories. Order matters — first match wins. */
const CATEGORY_RULES: Array<{ prefix: string; category: ContentCategory }> = [
  // Reference: API specs, protocol docs, benchmarks
  { prefix: 'apis/benchmarks/', category: 'reference' },
  { prefix: 'apis/actions/',    category: 'guide' },      // cookbook/how-to, not spec
  { prefix: 'apis/',            category: 'reference' },

  // SDK examples: framework integration code examples
  { prefix: 'sdk-examples/',    category: 'sdk-example' },

  // Guide: how-tos, quickstarts
  { prefix: 'guides/',          category: 'guide' },
  { prefix: 'examples/',        category: 'guide' },

  // Self-hosting: deployment, operations, configuration
  { prefix: 'self-hosting/',    category: 'self-hosting' },

  // Concept: architecture, IAM model, product/roadmap
  { prefix: 'concepts/',        category: 'concept' },
  { prefix: 'product/',         category: 'concept' },

  // Advisory: breaking-change and migration notices
  { prefix: 'support/advisory/', category: 'advisory' },
  { prefix: 'support/',          category: 'advisory' },

  // Other: legal, everything else
  { prefix: 'legal/',           category: 'other' },
];

function detectCategory(relPath: string): ContentCategory {
  for (const { prefix, category } of CATEGORY_RULES) {
    if (relPath.startsWith(prefix)) return category;
  }
  return 'other';
}

/** Per-category prompt hint — just a nudge, not a recipe. */
const CATEGORY_PROMPTS: Record<ContentCategory, { hint: string; pageKind: string }> = {
  reference: {
    pageKind: 'API / protocol reference',
    hint: 'Name the specific protocol, endpoint, or API resource and describe its exact purpose.',
  },
  guide: {
    pageKind: 'how-to / integration guide',
    hint: 'Focus on the specific task the developer will accomplish. Mention exact tools, providers (e.g., Okta, GitHub), or protocols involved.',
  },
  'sdk-example': {
    pageKind: 'SDK / framework integration example',
    hint: 'Lead with the framework or library name. Mention the auth library if one is used.',
  },
  concept: {
    pageKind: 'conceptual / architectural docs',
    hint: 'Lead with the concept or feature name and why it matters.',
  },
  advisory: {
    pageKind: 'technical advisory / breaking-change notice',
    hint:
      'This is a technical advisory, NOT a how-to guide. ' +
      'Extract the advisory number from the title (e.g. "Technical Advisory 10003" → "A-10003") and start with it. ' +
      'State what changed or broke and which ZITADEL versions are affected. ' +
      'Frame as a notice about a change, not as an instruction to the reader. ' +
      'Good: "A-10003: Default organization settings now apply to Login-UI when no org context is provided in ZITADEL v2.38.0" ' +
      'Bad: "Update default organization settings for ZITADEL Login-UI to improve registration flows effectively now"',
  },
  'self-hosting': {
    pageKind: 'self-hosting / operations guide',
    hint:
      'Lead with the specific operational task: deploy, configure, scale, migrate, or monitor. ' +
      'Name the exact technology when relevant: Kubernetes, Helm, Docker Compose, PostgreSQL, Prometheus, etc. ' +
      'Write naturally — do NOT pad with filler words like "quickly", "always", "securely always", "ready", or "efficiently now". ' +
      'Good: "Deploy ZITADEL on Kubernetes using Helm with PostgreSQL and an Ingress controller" ' +
      'Bad: "Install ZITADEL on Kubernetes using Helm with a PostgreSQL database and Ingress controller for secure access"',
  },
  other: {
    pageKind: 'documentation page',
    hint: 'Omit "ZITADEL" from the description when possible.',
  },
};

// ---------------------------------------------------------------------------
// CLI argument parsing
// ---------------------------------------------------------------------------

const { values: _args } = parseArgs({
  args: process.argv.slice(2),
  options: {
    'base-url':   { type: 'string',  default: 'http://127.0.0.1:1234' },
    model:        { type: 'string',  default: 'finetuned-meta-llama-4-scout-17b-16e-instruct-i1' },
    'dry-run':    { type: 'boolean', default: false },
    force:        { type: 'boolean', default: false },
    file:         { type: 'string' },
    delay:        { type: 'string',  default: '200' },
    'start-from': { type: 'string',  default: '0' },
    limit:        { type: 'string' },
  },
});

const BASE_URL    = _args['base-url'] as string;
const MODEL       = _args.model as string;
const DRY_RUN     = _args['dry-run'] as boolean;
const FORCE       = _args['force'] as boolean;
const SINGLE_FILE = _args.file as string | undefined;
const DELAY_MS    = Number(_args.delay);
const START_FROM  = Number(_args['start-from']);
const LIMIT       = _args.limit !== undefined ? Number(_args.limit) : Infinity;

if (isNaN(DELAY_MS))   { console.error('Error: --delay must be a number'); process.exit(1); }
if (isNaN(START_FROM)) { console.error('Error: --start-from must be a number'); process.exit(1); }
if (_args.limit !== undefined && isNaN(LIMIT)) { console.error('Error: --limit must be a number'); process.exit(1); }

const CONTENT_DIR = fileURLToPath(new URL('../content', import.meta.url));

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Recursively collect all .mdx file paths under a directory. */
async function globMdx(dir: string): Promise<string[]> {
  return fg(['**/*.mdx'], { cwd: dir, absolute: true, dot: false, followSymbolicLinks: false });
}

/**
 * Parse YAML frontmatter from an MDX string.
 */
function parseFrontmatter(content: string): {
  fm: Record<string, string>;
  rawFm: string;
  body: string;
} {
  const { hasFm, fmRaw, body } = splitFrontmatter(content);
  if (!hasFm) return { fm: {}, rawFm: '', body: content };

  const fm: Record<string, string> = {};
  for (const line of fmRaw.split('\n')) {
    const kv = line.match(/^(\w[\w_-]*):\s*(.*)$/);
    if (kv) fm[kv[1]] = kv[2].trim().replace(/^["']|["']$/g, '');
  }

  return { fm, rawFm: fmRaw, body };
}

/**
 * Returns true when the raw frontmatter block contains a `description` key
 * with a non-empty, non-trivial value.
 */
function hasRealDescription(rawFm: string): boolean {
  const lines = rawFm.split('\n');
  const idx = lines.findIndex((l) => /^description:\s*/.test(l));
  if (idx === -1) return false;

  const first = lines[idx].replace(/^description:\s*/, '').trim();
  if (first && !/^[>|][+-]?$/.test(first) && !['""', "''"].includes(first)) return true;

  for (let i = idx + 1; i < lines.length; i++) {
    const l = lines[i];
    if (/^\S/.test(l)) break;
    if (l.trim().length > 0) return true;
  }

  return false;
}

/**
 * Build a rich context string for the LLM by sending up to ~8000 chars of page content.
 *
 * Strategy:
 *   1. Extract the introductory sentence/paragraph and label it prominently.
 *   2. Extract all ## / ### headings as a full document outline.
 *   3. Send cleaned body prose up to 8000 chars with noise stripped:
 *      - imports, code fences, empty HTML detail/summary shells,
 *      - raw MDX/JSX expressions, markdown link URLs (keep display text),
 *      - markdown table alignment rows (keep header + data rows as text).
 */
function extractContext(body: string): string {
  const maxBodyChars = 4000; // Reduced from 8000 to prevent context size errors

  let cleaned = body
    // Strip imports
    .replace(/^import\s.*$/gm, '')
    // Strip code fence bodies entirely (method names are
    // extracted separately by extractMethodNames, so we don't need hints here)
    .replace(/```[^\n]*\n[\s\S]*?```/g, '')
    // Strip empty HTML detail/summary shells left after code fence removal
    .replace(/<details[^>]*>\s*<\/details>/gi, '')
    .replace(/<details[^>]*>\s*<summary[^>]*>.*?<\/summary>\s*<\/details>/gi, '')
    .replace(/<\/?(?:details|summary)[^>]*>/gi, '')
    // Strip raw MDX/JSX expressions (e.g. {props.summary ? props.summary : 'Code example'})
    .replace(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g, '')
    // Simplify markdown links: [display text](url) → display text
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
    // Simplify markdown table alignment rows: |:---|:---|
    .replace(/^\|[\s:|-]+\|$/gm, '')
    // Strip table pipe formatting but keep cell content (only for actual table rows with ≥2 pipes)
    .replace(/^(\|.*\|.*\|.*)$/gm, (_match, row: string) => row.replace(/^\|\s*/, '').replace(/\s*\|$/, ''))
    // Collapse triple+ newlines
    .replace(/\n{3,}/g, '\n\n')
    .trim();

  // Extract the introductory paragraph (first non-empty, non-heading block)
  let intro = '';
  const introMatch = cleaned.match(/^([^#\n][^\n]+(?:\n[^#\n][^\n]+)*)/);
  if (introMatch) {
    const candidate = introMatch[1].trim();
    // Only use if it's real prose (not just a link or very short)
    if (candidate.length > 30) {
      intro = candidate;
    }
  }

  // Build full heading outline (translate lifecycle-phase headings)
  const headings: string[] = [];
  for (const line of cleaned.split('\n')) {
    const m = line.match(/^\s*(#{2,3})\s+(.+?)\s*$/);
    if (m) {
      const indent = m[1].length === 3 ? '  -' : '-';
      headings.push(`${indent} ${m[2]}`);
    }
  }
  const outline =
    headings.length > 0
      ? `[DOCUMENT OUTLINE]\n${headings.join('\n')}\n\n`
      : '';

  // Send prose up to the budget — simple top-slice
  let prose = cleaned.slice(0, maxBodyChars).trim();
  if (cleaned.length > maxBodyChars) {
    // Cut at last word boundary to avoid mid-word truncation
    const lastSpace = prose.lastIndexOf(' ');
    if (lastSpace > maxBodyChars * 0.8) prose = prose.slice(0, lastSpace);
    prose += '\n[…truncated]';
  }

  let result = '';
  if (intro) result += `${intro}\n\n`;
  result += outline;
  if (prose) result += `[PAGE CONTENT]\n${prose}`;
  return result.trim();
}

/**
 * Sanitize LLM output: strip formatting artifacts, normalize casing, enforce length cap.
 * Content quality is the prompt's job — this only handles formatting.
 */
function sanitizeDescription(text: string): string {
  let clean = text.trim();

  // Strip surrounding quotes the LLM sometimes adds despite being told not to
  clean = clean.replace(/^["']|["']$/g, '').trim();

  // Strip accidental markdown formatting (bold, italics, inline code, links)
  clean = clean.replace(/(\*\*|__)(.*?)\1/g, '$2'); // bold
  clean = clean.replace(/(\*|_)(.*?)\1/g, '$2'); // italics
  clean = clean.replace(/`(.*?)`/g, '$1'); // inline code
  clean = clean.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1'); // links

  // Collapse newlines and whitespace runs
  clean = clean.replace(/\r?\n+/g, ' ').replace(/\s{2,}/g, ' ').trim();

  // Remove trailing period (prompt asks for none)
  clean = clean.replace(/\.$/, '');

  // Strip trailing filler words/phrases the LLM often pads with
  clean = clean.replace(
    /\s+(?:effectively\s+now|efficiently\s+now|effectively\s+always|securely\s+always|manually\s+afterwards|right\s+now|effectively|efficiently|smoothly|immediately|always|quickly|securely|ready|now)\s*$/i,
    '',
  );

  // Normalize terminology casing
  clean = clean.replace(/\bid[_\s]?tokens?\b/gi, 'ID token');
  clean = clean.replace(/\baccess[_\s]?tokens?\b/gi, 'access token');
  clean = clean.replace(/\brefresh[_\s]?tokens?\b/gi, 'refresh token');
  clean = clean.replace(/\bSAMLResponse\b/g, 'SAML response');
  clean = clean.replace(/\bzitadel\b/gi, 'ZITADEL');

  return clean;
}

/**
 * Slice content into its raw frontmatter and body parts.
 */
function splitFrontmatter(content: string): { hasFm: boolean; fmRaw: string; body: string } {
  const m = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/);
  if (!m) return { hasFm: false, fmRaw: '', body: content };
  return { hasFm: true, fmRaw: m[1], body: m[2] ?? '' };
}

/**
 * Inject or replace the `description` field inside the frontmatter block only.
 */
function injectDescription(content: string, description: string): string {
  // Use single-quote wrapping when description contains double quotes to avoid ugly escaping
  const hasDoubleQuotes = description.includes('"');
  const quote = hasDoubleQuotes ? "'" : '"';
  const escaped = hasDoubleQuotes
    ? description.replace(/'/g, "''")
    : description.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  const { hasFm, fmRaw, body } = splitFrontmatter(content);

  const eol = content.includes('\r\n') ? '\r\n' : '\n';
  const lines = hasFm ? fmRaw.split('\n').map((l) => l.replace(/\r$/, '')) : [];

  const descIdx = lines.findIndex((l) => /^description:\s*/.test(l));
  if (descIdx !== -1) {
    // Replace existing — also remove any continuation lines (block scalar)
    lines[descIdx] = `description: ${quote}${escaped}${quote}`;
    while (descIdx + 1 < lines.length && /^\s/.test(lines[descIdx + 1])) {
      lines.splice(descIdx + 1, 1);
    }
  } else {
    const titleIdx = lines.findIndex((l) => /^title:\s*/.test(l));
    if (titleIdx !== -1) {
      lines.splice(titleIdx + 1, 0, `description: ${quote}${escaped}${quote}`);
    } else {
      lines.unshift(`description: ${quote}${escaped}${quote}`);
    }
  }

  const fmBlock = `---${eol}${lines.join(eol)}${eol}---${eol}`;
  return hasFm ? fmBlock + body : fmBlock + content;
}

/**
 * Perform a chat completion call. Retries up to 3 times on network-level failures.
 */
async function callLLM(
  messages: Array<{ role: string; content: string }>,
  maxTokens = 150,
): Promise<string> {
  const MAX_ATTEMPTS = 3;
  let lastError: Error | undefined;

  for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60_000);
      let response: Response;
      try {
        response = await fetch(`${BASE_URL}/v1/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: MODEL,
            messages,
            max_tokens: maxTokens,
            temperature: 0.3,
            stop: ['\n\n'],
          }),
          signal: controller.signal,
        });
      } finally {
        clearTimeout(timeoutId);
      }

      if (!response.ok) {
        const text = await response.text();
        if (response.status < 500) throw new Error(`LLM API error ${response.status}: ${text}`);
        throw new Error(`LLM server error ${response.status}: ${text}`);
      }

      const json = (await response.json()) as {
        choices: Array<{ message: { content: string } }>;
      };
      return json.choices?.[0]?.message?.content ?? '';
    } catch (err) {
      lastError = err as Error;
      if (attempt < MAX_ATTEMPTS) {
        const backoffMs = 500 * 2 ** (attempt - 1);
        await new Promise((r) => setTimeout(r, backoffMs));
      }
    }
  }

  throw lastError;
}


/**
 * Generate a meta description for a single page.
 * One LLM call — no retries for content quality.
 */
async function generateDescription(
  title: string,
  context: string,
  category: ContentCategory,
  body: string,
  relPath: string,
  fm: Record<string, string> = {},
): Promise<string> {
  const { hint, pageKind } = CATEGORY_PROMPTS[category];

  const systemPrompt =
    'You are an expert technical SEO copywriter. Write exactly ONE meta description for a developer docs page.\n' +
    'Rules:\n' +
    '- Output exactly ONE plain-text sentence, no trailing period. If you cannot comply, output exactly: INVALID\n' +
    '- Target 16–20 words. If word count and character count conflict, prioritize word count.\n' +
    '- Structure: Verb + what (object) + when/where (context) + why (benefit).\n' +
    '- Start with a strong, specific action verb. Vary your verbs and DO NOT overuse "Enrich", "Configure", or "Customize".\n' +
    '- Include "ZITADEL" only when it reads naturally and adds clarity; otherwise omit.\n' +
    '- Prefer industry terms like: tokens, claims, SAML assertions, OIDC, webhooks, provisioning, SCIM, IdP, service provider.\n' +
    '- DO NOT use the words "trigger", "triggers", "pre userinfo", "pre creation", "post creation", or "lifecycle phases". Use standard terms like "custom authentication logic" or "OIDC claims enrichment" instead.\n' +
    '- Never start with "Learn", "This guide", or "In this guide".\n' +
    '- Do NOT pad the end of the description with filler words like "now", "quickly", "always", "effectively", "smoothly", "immediately", or "ready".\n' +
    '\n' +
    'Good examples:\n' +
    '- Add custom claims to ID tokens during token creation to support downstream authorization\n' +
    '- Authenticate service users for API calls without interactive login using Personal Access Tokens\n' +
    '- Mirror events between instances using the cockroach and postgres export commands to ensure data consistency\n' +
    '- Sync user profiles from Okta and GitHub during login to maintain up-to-date identity records\n' +
    '\n' +
    'Bad examples (DO NOT DO THIS):\n' +
    '- Enrich OIDC tokens with custom claims during issuance to support downstream authorization (DO NOT overuse "Enrich")\n' +
    '- Learn how to configure custom authentication logic for identity enrichment (DO NOT start with "Learn")\n' +
    '- This guide explains how to customize authentication flows using external identity providers (DO NOT start with "This guide")\n' +
    '- Configure custom authentication logic using post authentication triggers during login flows (DO NOT use internal jargon like "post authentication triggers")\n' +
    '\n' +
    hint;

  // Surface SDK-example frontmatter when available
  let sdkHint = '';
  if (relPath.startsWith('sdk-examples/')) {
    const parts: string[] = [];
    if (fm['auth_library']) parts.push(`Auth library: ${fm['auth_library']}`);
    if (fm['auth_flow']) parts.push(`Auth flow: ${fm['auth_flow']}`);
    if (parts.length > 0) sdkHint = `\n${parts.join(' | ')}\n`;
  }

  // Surface tags/keywords if available
  let tagsHint = '';
  if (fm['tags']) tagsHint = `\nTags: ${fm['tags']}\n`;
  if (fm['keywords']) tagsHint += `\nKeywords: ${fm['keywords']}\n`;

  const userPrompt =
    `File path: ${relPath}\n` +
    `${pageKind}: ${title}\n` +
    `${sdkHint}` +
    `${tagsHint}\n` +
    `${context}`;

  const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ];

  // Retry up to 3 times if the model misses the length target or uses banned words
  const MAX_ATTEMPTS = 3;
  let result = '';
  for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
    const raw = await callLLM(messages);
    result = sanitizeDescription(raw);
    
    const hasBannedWords = /\b(trigger|triggers|pre userinfo|pre creation|post creation|lifecycle phases)\b/i.test(result);
    const startsWithBanned = /^(Learn|This guide|In this guide)\b/i.test(result);
    
    if (result.length >= 90 && result.length <= 160 && !hasBannedWords && !startsWithBanned) break;
    
    if (attempt < MAX_ATTEMPTS) {
      messages.push({ role: 'assistant', content: raw });
      
      if (hasBannedWords) {
        messages.push({ role: 'user', content: `You used a banned word. Rewrite without using "trigger", "triggers", "pre userinfo", "pre creation", "post creation", or "lifecycle phases".` });
      } else if (startsWithBanned) {
        messages.push({ role: 'user', content: `You started with a banned phrase. Rewrite without starting with "Learn", "This guide", or "In this guide".` });
      } else if (result.length > 160) {
        messages.push({ role: 'user', content: `Too long (${result.length} chars). Shorten to under 150 characters while keeping it a complete sentence.` });
      } else {
        messages.push({ role: 'user', content: `Too short (${result.length} chars). Expand to 100–145 characters by adding more specific detail from the page content.` });
      }
    }
  }

  // Post-strip ZITADEL from legal documents — the LLM often ignores the in-prompt ban
  const isLegal = category === 'other' && /\blegal\b/i.test(relPath);
  if (isLegal) {
    result = result
      .replace(/\bZITADEL['']s\s+/gi, '')
      .replace(/\bZITADEL['']s\b/gi, '')
      .replace(/\bfor\s+ZITADEL\b/gi, '')
      .replace(/\bof\s+ZITADEL\b/gi, '')
      .replace(/\bin\s+ZITADEL\b/gi, '')
      .replace(/\bZITADEL\s+/gi, '')
      .replace(/\bZITADEL\b/gi, '')
      .replace(/\s{2,}/g, ' ')
      .trim();
    // Re-capitalize after stripping
    if (result.length > 0) result = result[0].toUpperCase() + result.slice(1);
  }

  return result;
}

/** Sleep helper. */
const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main() {
  console.log(`LLM endpoint : ${BASE_URL}`);
  console.log(`Model        : ${MODEL}`);
  console.log(`Dry run      : ${DRY_RUN}`);
  console.log(`Force        : ${FORCE}`);
  console.log(`Delay        : ${DELAY_MS}ms`);
  console.log(`Excluded     : reference/, v*/, apis/proto/, **/index.mdx\n`);

  // Build file list
  let files: string[];
  if (SINGLE_FILE) {
    const resolved = resolve(CONTENT_DIR, SINGLE_FILE);
    const rel = relative(CONTENT_DIR, resolved);
    if (rel.startsWith('..')) {
      console.error(`Error: --file path escapes the content directory: ${SINGLE_FILE}`);
      process.exit(1);
    }
    files = [resolved];
  } else {
    const all = await globMdx(CONTENT_DIR);
    files = all.filter((f) => {
      const rel = relative(CONTENT_DIR, f);
      if (basename(f).startsWith('_')) return false;
      if (isExcluded(rel)) return false;
      return true;
    });
    files.sort();
  }

  // Read and filter eligible files
  type EligibleFile = { path: string; relPath: string; content: string; fm: Record<string, string>; body: string };
  const eligible: EligibleFile[] = [];
  for (const f of files) {
    const content = await readFile(f, 'utf-8');
    const { fm, rawFm, body } = parseFrontmatter(content);
    if (FORCE || !hasRealDescription(rawFm)) {
      eligible.push({ path: f, relPath: relative(CONTENT_DIR, f), content, fm, body });
    }
  }

  console.log(`Total non-generated MDX files : ${files.length}`);
  console.log(`Missing description           : ${eligible.length}`);
  if (START_FROM > 0) console.log(`Skipping first                : ${START_FROM}`);
  console.log('');

  const toProcess = eligible.slice(START_FROM, START_FROM + (isFinite(LIMIT) ? LIMIT : eligible.length));
  let succeeded = 0;
  let failed = 0;

  for (let i = 0; i < toProcess.length; i++) {
    const { path: filePath, relPath, content, fm, body } = toProcess[i];
    const globalIndex = START_FROM + i + 1;
    const progress = `[${globalIndex}/${eligible.length}]`;

    const title = fm['title'] ?? basename(filePath, '.mdx');
    const category = detectCategory(relPath);
    const context = extractContext(body);

    process.stdout.write(`${progress} [${category}] ${relPath} … `);

    try {
      const description = await generateDescription(title, context, category, body, relPath, fm);
      const charCount = description.length;

      if (charCount < 50) {
        console.log(`SKIPPED — description too short after sanitization (${charCount} chars)`);
        failed++;
        continue;
      }

      if (DRY_RUN) {
        console.log(`\n  → (dry-run) ${description} [${charCount} chars]`);
      } else {
        const updated = injectDescription(content, description);
        if (updated !== content) writeFileSync(filePath, updated, 'utf-8');
        console.log(`done [${charCount} chars]`);
      }

      succeeded++;
    } catch (err) {
      console.log(`FAILED — ${(err as Error).message}`);
      failed++;
    }

    if (i < toProcess.length - 1) await sleep(DELAY_MS);
  }

  console.log(`\n✓ Succeeded: ${succeeded}  ✗ Failed: ${failed}`);
  if (failed > 0) process.exit(1);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
