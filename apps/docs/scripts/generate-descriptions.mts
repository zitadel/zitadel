/**
 * generate-descriptions.mts
 *
 * Generates SEO meta description frontmatter for MDX docs pages that are missing one,
 * using a local OpenAI-compatible LLM endpoint (e.g. LM Studio).
 *
 * Usage:
 *   node --experimental-strip-types apps/docs/scripts/generate-descriptions.mts [options]
 *
 * Options:
 *   --base-url <url>    LLM server base URL  (default: http://127.0.0.1:1234)
 *   --model <id>        Model identifier     (default: qwen2.5-coder-14b-instruct)
 *   --dry-run           Preview without writing files
 *   --file <path>       Process a single file only (relative to content/)
 *   --delay <ms>        Delay between API calls in ms (default: 200)
 *   --start-from <n>    Skip the first N eligible files (resume after interruption)
 *   --limit <n>         Process at most N files then stop
 *
 * Excluded content (generated / versioned — must not be edited):
 *   - content/reference/          auto-generated REST/gRPC API reference (generate-api-reference target)
 *   - content/v<N.M>/             versioned doc snapshots fetched at build time (fetch-remote-content target)
 *   - content/apis/proto/         buf-generated protobuf docs (gitignored)
 *   - any index.mdx              all index pages are generated by the generate-index-pages target
 *   - files starting with _       MDX partials (not navigable pages)
 */

import { writeFileSync } from 'node:fs';
import { readFile } from 'node:fs/promises';
import { relative, basename, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { parseArgs } from 'node:util';
import fg from 'fast-glob';

// ---------------------------------------------------------------------------
// Exclusion rules for generated / versioned / partial content.
// ---------------------------------------------------------------------------

/** Top-level directory names that are entirely auto-generated. */
const EXCLUDED_DIR_PREFIXES = [
  'reference', // generate-api-reference target → content/reference/api/
];

/** Top-level directory patterns that are auto-generated or fetched. */
const EXCLUDED_DIR_PATTERNS = [
  /^v\d/, // versioned snapshots: v4.10, v4.11, … (fetch-remote-content target)
];

/** Path prefixes (relative to content/) that are entirely auto-generated. */
const EXCLUDED_PATH_PREFIXES = [
  'apis/proto/', // buf-generated protobuf docs — gitignored, not committed
];

function isExcluded(contentRelPath: string): boolean {
  // File-level: all index.mdx files are generated by the generate-index-pages target
  if (basename(contentRelPath) === 'index.mdx') return true;

  const first = contentRelPath.split('/')[0];
  if (EXCLUDED_DIR_PREFIXES.includes(first)) return true;
  if (EXCLUDED_DIR_PATTERNS.some((re) => re.test(first))) return true;
  if (EXCLUDED_PATH_PREFIXES.some((p) => contentRelPath.startsWith(p))) return true;

  return false;
}

// ---------------------------------------------------------------------------
// Content-type classification
// ---------------------------------------------------------------------------

type ContentType =
  | 'advisory'      // support/advisory/a*.mdx — structured security/breaking-change advisories
  | 'benchmark'     // apis/benchmarks/**       — versioned performance benchmark results
  | 'api-reference' // apis/**                  — protocol specs (OIDC/OAuth/SAML/SCIM/Actions)
  | 'concept'       // concepts/**              — architectural explainers and IAM model docs
  | 'quickstart'    // guides/start/**          — getting-started / quickstart guides
  | 'guide'         // guides/**                — how-to guides (integrate/manage/migrate/scenarios)
  | 'sdk-example'   // sdk-examples/**, examples/** — per-framework auth integration examples
  | 'deploy'        // self-hosting/deploy/**   — platform-specific installation guides
  | 'operations'    // self-hosting/**          — production operations (HA, TLS, scaling, …)
  | 'legal'         // legal/**                 — ToS, DPA, privacy policy, subprocessors
  | 'product'       // product/**               — roadmap, release cycle, feature status
  | 'generic';      // fallback for anything not matched above

/**
 * Derive the content type from the file's path, with a lightweight content-based
 * override for edge cases (e.g. conceptual content nested inside apis/).
 */
function detectContentType(relPath: string, excerpt = ''): ContentType {
  // Path-based classification (primary signal)
  let type: ContentType;
  if      (relPath.startsWith('support/advisory/'))   type = 'advisory';
  else if (relPath.startsWith('apis/benchmarks/'))    type = 'benchmark';
  else if (relPath.startsWith('apis/'))               type = 'api-reference';
  else if (relPath.startsWith('concepts/'))           type = 'concept';
  else if (relPath.startsWith('guides/start/'))       type = 'quickstart';
  else if (relPath.startsWith('guides/'))             type = 'guide';
  else if (relPath.startsWith('sdk-examples/') || relPath.startsWith('examples/')) type = 'sdk-example';
  else if (relPath.startsWith('self-hosting/deploy/')) type = 'deploy';
  else if (relPath.startsWith('self-hosting/'))       type = 'operations';
  else if (relPath.startsWith('legal/'))              type = 'legal';
  else if (relPath.startsWith('product/'))            type = 'product';
  else                                                type = 'generic';

  // Content-based override: paths like apis/ occasionally contain walkthrough content
  if (excerpt) {
    const hasPrereqs = /\bprerequisites?\b/i.test(excerpt);
    if (type === 'api-reference' || type === 'generic') {
      if (hasPrereqs && /\bsteps?\b/i.test(excerpt))          return 'guide';
      if (hasPrereqs && /\bquick\s*start\b/i.test(excerpt))  return 'quickstart';
    }
    if (type === 'generic' && /\b(endpoint|grant|parameter)\b/i.test(excerpt)) {
      return 'api-reference';
    }
  }

  return type;
}

/**
 * Per-content-type prompt configuration.
 *
 * focusClause  — appended to the shared system prompt to steer topical emphasis.
 * pageKind     — human-readable label used in the user-turn framing and progress output.
 */
const PROMPT_CONFIGS: Record<ContentType, { focusClause: string; pageKind: string }> = {
  advisory: {
    pageKind: 'Technical Advisory',
    focusClause:
      'This is a Technical Advisory. ' +
      'Include the advisory ID if it appears in the title or excerpt — do NOT invent an ID. ' +
      'State the ZITADEL versions affected if mentioned, otherwise omit version numbers. ' +
      'Name the category of change (security vulnerability, breaking behaviour change, deprecation). ' +
      'Mention whether a mitigation or upgrade path is available. ' +
      'Do not sensationalise; use neutral, factual language.',
  },
  benchmark: {
    pageKind: 'performance benchmark page',
    focusClause:
      'This is a performance benchmark page. ' +
      'Mention the ZITADEL version tested and the benchmark scenario or test name (e.g. machine JWT grant, /token endpoint). ' +
      'Describe what was measured (e.g. request latency, throughput, error rate) rather than quoting raw numbers. ' +
      'If the excerpt states tests were halted or degraded at a certain load, mention that outcome briefly. ' +
      'Do NOT reproduce numeric tables or percentile notation. ' +
      'Extract 1–2 technical terms (e.g. endpoint name, test tool) directly from the excerpt.',
  },
  'api-reference': {
    pageKind: 'protocol or API reference page',
    focusClause:
      'This is a protocol or API reference page. ' +
      'Name the specific protocol or API covered (OIDC, OAuth 2.0, SAML 2.0, SCIM 2.0, Actions, etc.). ' +
      'Describe which endpoints, parameters, grant types, or scripting objects the page defines. ' +
      'Mention RFC or OpenID spec identifiers ONLY if they appear verbatim in the excerpt — otherwise omit them. ' +
      'Focus on what a developer can configure or call. ' +
      'Extract 1–2 technical keywords directly from the excerpt.',
  },
  concept: {
    pageKind: 'conceptual documentation page',
    focusClause:
      'This is a conceptual/architectural documentation page. ' +
      'Explain what the concept IS and its specific role in ZITADEL\'s IAM model. ' +
      'Do NOT use action-verb openings like "Learn how" or "Discover". ' +
      'Instead, open with the concept name or a defining noun phrase. ' +
      'Mention which use cases or design decisions the concept enables. ' +
      'Use specific terminology from the excerpt rather than generic IAM vocabulary.',
  },
  quickstart: {
    pageKind: 'quickstart guide',
    focusClause:
      'This is a quickstart or getting-started guide. ' +
      'State the concrete end-to-end goal, the protocol or framework used (e.g. OIDC PKCE, Next.js), ' +
      'and the tangible outcome the reader achieves. ' +
      'Convey that the guide is fast to complete without inventing a time estimate not in the content. ' +
      'Extract 1–2 technical keywords (e.g. framework name, auth flow) directly from the excerpt.',
  },
  guide: {
    pageKind: 'how-to guide',
    focusClause:
      'This is a how-to guide. ' +
      'Name the specific task or goal (e.g. configuring an IDP, migrating users, enabling MFA). ' +
      'Mention the relevant protocol, tool, or ZITADEL feature involved. ' +
      'Note if the guide applies to ZITADEL Cloud, self-hosted deployments, or both. ' +
      'For migration guides, name the source system if the excerpt mentions one. ' +
      'Extract 1–2 technical keywords directly from the excerpt.',
  },
  'sdk-example': {
    pageKind: 'SDK or framework example page',
    focusClause:
      'This is an SDK or framework integration example. ' +
      'Name the framework (e.g. Next.js, Angular, Go) and the auth library if one is used. ' +
      'State the authentication flow (e.g. PKCE, device code, client credentials). ' +
      'Describe what the working example demonstrates end-to-end. ' +
      'Extract 1–2 technical keywords (framework, auth library, flow) directly from the excerpt.',
  },
  deploy: {
    pageKind: 'platform deployment guide',
    focusClause:
      'This is a platform deployment guide for self-hosting ZITADEL. ' +
      'Name the target platform (e.g. Linux, macOS, Docker Compose, Kubernetes). ' +
      'Mention key prerequisites and the deployment outcome (a running ZITADEL instance). ' +
      'Do not mention cloud-hosted ZITADEL unless the content explicitly does. ' +
      'Extract 1–2 technical keywords (e.g. platform name, database) directly from the excerpt.',
  },
  operations: {
    pageKind: 'production operations guide',
    focusClause:
      'This is a production operations guide for self-hosted ZITADEL. ' +
      'Name the specific operations concern (e.g. high availability, TLS configuration, ' +
      'database tuning, horizontal scaling, metrics/monitoring, reverse proxy setup). ' +
      'Emphasise the production-readiness or reliability angle. ' +
      'Extract 1–2 technical keywords directly from the excerpt.',
  },
  legal: {
    pageKind: 'legal document',
    focusClause:
      'This is a legal document. ' +
      'State the document type (Terms of Service, Data Processing Agreement, Privacy Policy, etc.), ' +
      'identify the relevant parties (e.g. ZITADEL and its customers/users), ' +
      'and describe the key service scope or obligation covered. ' +
      'Use neutral, non-promotional language. ' +
      'Do NOT include protocol names (OIDC, OAuth, SAML) or technical keywords unless they appear in the excerpt.',
  },
  product: {
    pageKind: 'product roadmap or release page',
    focusClause:
      'This is a product roadmap or release-cycle page. ' +
      'Mention the version(s) or quarter(s) in scope. ' +
      'Highlight which features reach GA, enter beta, or are deprecated. ' +
      'Note any breaking changes if present in the excerpt. ' +
      'Use specific feature names from the excerpt rather than generic product vocabulary.',
  },
  generic: {
    pageKind: 'documentation page',
    focusClause: '', // rely solely on the shared base prompt
  },
};

// ---------------------------------------------------------------------------
// CLI argument parsing
// ---------------------------------------------------------------------------

const { values: _args } = parseArgs({
  args: process.argv.slice(2),
  options: {
    'base-url':   { type: 'string',  default: 'http://127.0.0.1:1234' },
    model:        { type: 'string',  default: 'qwen2.5-coder-14b-instruct' },
    'dry-run':    { type: 'boolean', default: false },
    file:         { type: 'string' },
    delay:        { type: 'string',  default: '200' },
    'start-from': { type: 'string',  default: '0' },
    limit:        { type: 'string' },
  },
});

const BASE_URL   = _args['base-url'] as string;
const MODEL      = _args.model as string;
const DRY_RUN    = _args['dry-run'] as boolean;
const SINGLE_FILE = _args.file as string | undefined;
const DELAY_MS   = Number(_args.delay);
const START_FROM = Number(_args['start-from']);
const LIMIT      = _args.limit !== undefined ? Number(_args.limit) : Infinity;

if (isNaN(DELAY_MS))    { console.error('Error: --delay must be a number'); process.exit(1); }
if (isNaN(START_FROM))  { console.error('Error: --start-from must be a number'); process.exit(1); }
if (_args.limit !== undefined && isNaN(LIMIT)) { console.error('Error: --limit must be a number'); process.exit(1); }

const CONTENT_DIR = fileURLToPath(new URL('../content', import.meta.url));

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Recursively collect all .mdx file paths under a directory. */
async function globMdx(dir: string): Promise<string[]> {
  return fg(['**/*.mdx'], { cwd: dir, absolute: true, dot: false, followSymbolicLinks: false });
}

/**
 * Parse YAML frontmatter from an MDX string.
 * Delegates to splitFrontmatter so there is exactly one definition of "what is
 * frontmatter" — prevents subtle divergence between the two functions.
 */
function parseFrontmatter(content: string): {
  fm: Record<string, string>;
  rawFm: string;
  body: string;
} {
  const { hasFm, fmRaw, body } = splitFrontmatter(content);
  if (!hasFm) return { fm: {}, rawFm: '', body: content };

  // Best-effort flat key→value parse for simple scalar values.
  // Multi-line YAML (block scalars, lists) is not normalised here; presence
  // checks should use hasRealDescription() on rawFm rather than this map.
  const fm: Record<string, string> = {};
  for (const line of fmRaw.split('\n')) {
    const kv = line.match(/^(\w[\w_-]*):\s*(.*)$/);
    if (kv) fm[kv[1]] = kv[2].trim().replace(/^["']|["']$/g, '');
  }

  return { fm, rawFm: fmRaw, body };
}

/**
 * Returns true when the raw frontmatter block contains a `description` key
 * with a non-empty, non-trivial value.
 *
 * Handles three forms:
 *   description: plain text      → true
 *   description: ">"             → true  (quoted scalar, not a block indicator)
 *   description: >               → scan subsequent indented lines
 *   description: |               → scan subsequent indented lines
 *   description:  (empty)        → false
 *   description: ""              → false
 */
function hasRealDescription(rawFm: string): boolean {
  const lines = rawFm.split('\n');
  const idx = lines.findIndex((l) => /^description:\s*/.test(l));
  if (idx === -1) return false;

  const first = lines[idx].replace(/^description:\s*/, '').trim();

  // Inline scalar with actual content (not empty-quoted strings)
  if (first && !/^[>|][+-]?$/.test(first) && !['""', "''"].includes(first)) return true;

  // Block scalar indicator (>, |, >-, |-) or truly empty value:
  // scan subsequent indented lines for any non-blank content.
  for (let i = idx + 1; i < lines.length; i++) {
    const l = lines[i];
    if (/^\S/.test(l)) break; // reached a new top-level key
    if (l.trim().length > 0) return true;
  }

  return false;
}

/**
 * Build a compact, representative context string for the LLM.
 *
 * Strategy:
 *   1. Extract all ## / ### headings as a page-scope outline (the model sees
 *      every major topic even on long pages).
 *   2. Append filtered body prose: cap bullet lines at 8 so long trigger-lists
 *      don't crowd out the opening paragraphs, then slice to maxBodyChars.
 *   3. For benchmarks, append a deduplicated "Key signals" block of lines that
 *      mention versions, endpoints, or load terms — giving the model enough
 *      scenario context even when the main excerpt is mostly tables.
 */
function extractContext(body: string, maxBodyChars = 900, contentType?: ContentType): string {
  // --- 1. Strip code fences and import lines ---------------------------------
  // MDX component tags are intentionally left intact; LLMs handle them well
  // as structural context, and stripping them can silently delete inline text.
  const cleaned = body
    .replace(/^import\s.*$/gm, '')
    // Keep only the first (most informative) line of each code fence
    .replace(/```(?:\w+)?\n([^\n]*)(?:[\s\S]*?)```/g, '[$1]')
    .replace(/```/g, '')
    .replace(/\n{3,}/g, '\n\n')
    .trim();

  // --- 2. Build heading outline (## and ###, deduplicated) --------------------
  const headings: string[] = [];
  for (const line of cleaned.split('\n')) {
    // Trim leading whitespace (indented headings) and trailing spaces
    const m = line.match(/^\s*(#{2,3})\s+(.+?)\s*$/);
    if (m) headings.push(`${m[1]} ${m[2]}`);
  }
  const uniqHeadings = Array.from(new Set(headings));
  const outline =
    uniqHeadings.length > 0 ? `Page sections:\n${uniqHeadings.join('\n')}\n\n` : '';

  // --- 3. Prose excerpt: cap bullet lines to avoid list domination ------------
  const allLines = cleaned
    .split('\n')
    .filter((l) => !l.match(/^\s*#{1,6}\s/))
    .filter((l) => !l.match(/^\s*(Code examples?|Examples?)\s*$/i))
    .filter((l) => !l.match(/^\s*https?:\/\/\S+\s*$/))
    .filter((l) => !l.match(/^\s*\|.*\|\s*$/)); // strip Markdown table rows

  const proseLines: string[] = [];
  let bulletCount = 0;
  for (const line of allLines) {
    if (/^\s*[-*]\s/.test(line)) {
      if (bulletCount < 8) { proseLines.push(line); bulletCount++; }
    } else {
      proseLines.push(line);
    }
  }
  let prose = proseLines.join('\n').slice(0, maxBodyChars).trim();

  // --- 4. Benchmark signal lines: keyword-matched lines anchor the scenario ---
  // These lines are extracted separately so numeric/load context reaches the
  // model without the model being asked to reproduce numbers in its output.
  if (contentType === 'benchmark') {
    const signalRe = /\bv?\d+\.\d+|\/token\b|k6\b|latency|throughput|p9\d\b|error|halt|degrad|VUs?\b|iterations?\b|req\/s|rps\b/i;
    const signals = cleaned
      .split('\n')
      .filter((l) => signalRe.test(l) && l.trim().length > 0)
      .map((l) => l.trim())
      .filter((l, i, arr) => arr.indexOf(l) === i) // deduplicate
      .slice(0, 10)
      .join('\n');
    if (signals) prose = `${prose}\n\nKey signals:\n${signals}`;
  }

  return (outline + prose).trim();
}

/**
 * Sanitize LLM output to prevent frontmatter corruption and ensure quality.
 * Strips markdown, conversational prefixes, and enforces a hard character cap.
 */
function sanitizeDescription(text: string, maxLen = 160): { text: string; truncated: boolean } {
  let clean = text.trim();

  // Strip surrounding quotes
  clean = clean.replace(/^["']|["']$/g, '').trim();

  // Strip common conversational/label prefixes the model might add
  clean = clean
    .replace(/^(meta\s+description:|description:|here is (the )?meta description:|sure[,!]?\s)/i, '')
    .trim();

  // Strip rogue markdown that could corrupt YAML (bold, italic, inline code)
  clean = clean.replace(/[*`_]/g, '');

  // Guard against YAML-breaking newlines (belt-and-suspenders: stop seqs should
  // prevent these, but a model that prefixes a blank line can still sneak one in)
  clean = clean.replace(/\r?\n+/g, ' ');

  // Collapse any runs of whitespace (spaces, tabs, stray CRs) left by stripping
  clean = clean.replace(/\s{2,}/g, ' ').trim();

  // Strip leading/trailing dashes, em-dashes, and colons the model occasionally adds
  clean = clean.replace(/^[\s\-–—:]+/, '').trim();
  clean = clean.replace(/[\s\-–—:]+$/, '').trim();

  // Remove trailing period for consistency
  clean = clean.replace(/\.$/, '');

  // Normalize ZITADEL casing — models sometimes write "Zitadel" or "zitadel"
  clean = clean.replace(/\bzitadel\b/gi, 'ZITADEL');

  // Hard cap at maxLen: cut to last whole word, never append ellipses.
  // Track truncation — callers treat it as a soft failure and may retry.
  let truncated = false;
  if (clean.length > maxLen) {
    truncated = true;
    const cut = clean.slice(0, maxLen);
    const lastSpace = cut.lastIndexOf(' ');
    clean = lastSpace > 40 ? cut.slice(0, lastSpace) : cut.trim();
  }

  return { text: clean, truncated };
}

/**
 * Slice content into its raw frontmatter and body parts.
 * All frontmatter edits operate on `fmRaw` so regexes can never match lines
 * in the document body or code blocks.
 */
function splitFrontmatter(content: string): { hasFm: boolean; fmRaw: string; body: string } {
  const m = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/);
  if (!m) return { hasFm: false, fmRaw: '', body: content };
  return { hasFm: true, fmRaw: m[1], body: m[2] ?? '' };
}

/**
 * Inject or replace the `description` field inside the frontmatter block only.
 * By operating on `fmRaw` exclusively we can never accidentally match a
 * `description:` or `title:` line that appears elsewhere in the document body.
 */
function injectDescription(content: string, description: string): string {
  // Escape backslashes first (YAML double-quote rules), then double-quotes
  const escaped = description.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  const { hasFm, fmRaw, body } = splitFrontmatter(content);

  // Detect the file's native line ending so we don't introduce CRLF/LF churn.
  const eol = content.includes('\r\n') ? '\r\n' : '\n';

  // Normalize lines: strip trailing \r so manipulation is clean, then re-join
  // with the native EOL at the end.
  const lines = hasFm ? fmRaw.split('\n').map((l) => l.replace(/\r$/, '')) : [];
  const descIdx = lines.findIndex((l) => /^description:\s*/.test(l));
  if (descIdx !== -1) {
    // Replace existing (possibly empty) description key in-place
    lines[descIdx] = `description: "${escaped}"`;
  } else {
    const titleIdx = lines.findIndex((l) => /^title:\s*/.test(l));
    if (titleIdx !== -1) {
      // Insert immediately after the title line
      lines.splice(titleIdx + 1, 0, `description: "${escaped}"`);
    } else {
      // Fallback: prepend as first frontmatter key
      lines.unshift(`description: "${escaped}"`);
    }
  }

  const fmBlock = `---${eol}${lines.join(eol)}${eol}---${eol}`;
  return hasFm ? fmBlock + body : fmBlock + content;
}

/**
 * Perform a single chat completion call and return raw content.
 * Retries up to 3 times on network-level failures (5xx, timeout, connection drop)
 * using exponential backoff, so transient local-LLM hangs don't fail the whole run.
 */
async function callLLM(
  messages: Array<{ role: string; content: string }>,
  stopSeqs: string[] = ['\n\n', '\r\n\r\n'],
): Promise<string> {
  const MAX_ATTEMPTS = 3;
  let lastError: Error | undefined;

  for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60_000);
      let response: Response;
      try {
        response = await fetch(`${BASE_URL}/v1/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: MODEL,
            messages,
            max_tokens: 120,
            temperature: 0.3,
            stop: stopSeqs,
          }),
          signal: controller.signal,
        });
      } finally {
        clearTimeout(timeoutId);
      }

      if (!response.ok) {
        const text = await response.text();
        // Only retry on server-side errors (5xx); bubble client errors immediately
        if (response.status < 500) throw new Error(`LLM API error ${response.status}: ${text}`);
        throw new Error(`LLM server error ${response.status}: ${text}`);
      }

      const json = (await response.json()) as {
        choices: Array<{ message: { content: string } }>;
      };

      // Keep only the first line — defends against models that prefix with a blank
      // line (which stop:[LF] would turn into empty output).
      const rawContent = json.choices?.[0]?.message?.content ?? '';
      return rawContent.split(/\r?\n/)[0];
    } catch (err) {
      lastError = err as Error;
      if (attempt < MAX_ATTEMPTS) {
        const backoffMs = 500 * 2 ** (attempt - 1); // 500ms, 1000ms
        await new Promise((r) => setTimeout(r, backoffMs));
      }
    }
  }

  throw lastError;
}

/**
 * Returns true when the raw LLM output has obvious format problems that the
 * sanitizer can fix but that also indicate the model ignored the instructions.
 * Used to decide whether to retry even when the length happens to be fine.
 */
function looksBad(raw: string): boolean {
  const t = raw.trim();
  if (!t) return true; // empty — model hit stop on a leading newline
  if (/^["'].*["']$/.test(t)) return true; // fully quoted
  // Label prefixes: "Meta description:", "Meta description -", "- item", "* item"
  if (/^(meta\s*description\s*[:\-]|description\s*[:\-])/i.test(t)) return true;
  if (/^[-*]\s+/.test(t)) return true; // bullet list start
  if (/[`*_]/.test(t)) return true; // markdown artifacts
  return false;
}

interface GenerateResult {
  description: string;
  rawFirstLen: number;
  rawRetryLen: number | null; // null when no retry was attempted
  retried: boolean;
}

/** Call the local LLM and return a sanitized, length-validated description.
 *  Retries once if the first result is out of the 130–160 char range OR has bad formatting. */
async function generateDescription(
  title: string,
  context: string,
  contentType: ContentType,
): Promise<GenerateResult> {
  const { focusClause, pageKind } = PROMPT_CONFIGS[contentType];

  // Shared base constraints — format, length, tone — applied to every content type.
  // Keyword extraction is intentionally NOT here; it is added per-type to avoid
  // forcing technical terms into legal, advisory, or product descriptions.
  const basePrompt =
    'You write SEO meta descriptions for ZITADEL technical documentation. ' +
    'Return ONLY the meta description text (no labels, no JSON, no quotes). ' +
    'Write exactly ONE sentence in plain text. ' +
    'Length MUST be 130–160 characters INCLUDING spaces. Do NOT exceed 160. ' +
    'No markdown, no emojis, no exclamation marks, no ellipses. Do not end with a period. ' +
    'Use at most two commas; avoid listing more than two protocol or product names. ' +
    'Avoid semicolons. Avoid generic openings like "This guide", "This page", "Learn how", "In this article". ' +
    'Include "ZITADEL" exactly once; omit it entirely in legal documents where it is already implied. ' +
    'Summarize the overall scope of the page (top 2–3 topics), not a single subsection. ' +
    'If the excerpt contains multiple major sections (e.g., OIDC, SAML, users, IDPs), reflect 2–3 of them rather than focusing on the first. ' +
    'Do NOT invent version numbers, feature names, or identifiers not present in the excerpt. ' +
    'If the page covers deprecation or migration, mention it neutrally.';

  // Append the type-specific focus clause when present.
  const systemPrompt = focusClause ? `${basePrompt}\n\n${focusClause}` : basePrompt;

  const userPrompt =
    `This is a ${pageKind}.\n` +
    `Title: ${title}\n` +
    `Excerpt:\n${context}\n\n` +
    `Meta description:`;

  const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ];

  let rawFirst = await callLLM(messages);
  const { text: firstText, truncated: firstTruncated } = sanitizeDescription(rawFirst);
  let desc = firstText;

  // Quality helpers --------------------------------------------------------
  const inRange        = (len: number) => len >= 130 && len <= 160;
  const distFromRange  = (len: number) => Math.max(0, 130 - len, len - 160);
  // Count whole-word occurrences of ZITADEL (sanitizer has already uppercased them).
  const countZITADEL   = (s: string) => (s.match(/\bZITADEL\b/g) ?? []).length;
  const countCommas    = (s: string) => (s.match(/,/g) ?? []).length;

  // Legal pages should NOT mention ZITADEL (it is implied); all others need exactly one.
  const zOkFor = (s: string) =>
    contentType === 'legal' ? countZITADEL(s) === 0 : countZITADEL(s) === 1;

  // Only trigger a retry on raw length when the model missed by more than 20 chars
  // — minor over/undershoot is often corrected by sanitization, and we don't
  // want a spurious retry just because a trailing quote bumps raw by 2 chars.
  const rawTooFarOff   = distFromRange(rawFirst.trim().length) > 20;

  // Trigger retry when sanitized output misses the window, has bad format,
  // was truncated, has the wrong ZITADEL count, or has more than 2 commas.
  // (2 commas is a reasonable limit: "OIDC, OAuth 2.0, and SAML" = 2 commas.)
  const needsRetry =
    rawTooFarOff ||
    !inRange(firstText.length) ||
    looksBad(rawFirst) ||
    firstTruncated ||
    !zOkFor(firstText) ||
    countCommas(firstText) > 2;

  let retried = false;
  let rawRetryLen: number | null = null;

  if (needsRetry) {
    retried = true;
    const retryMessages = [
      ...messages,
      { role: 'assistant', content: rawFirst },
      {
        role: 'user',
        content:
          `That was ${rawFirst.trim().length} characters. Rewrite to be 130–160 characters (inclusive), including spaces. ` +
          `Return ONLY plain text — no quotes, no labels, no markdown. ` +
          `Make sure it is a complete sentence that does not need to be cut off. Keep the technical meaning.\n\nMeta description:`,
      },
    ];
    const rawRetry = await callLLM(retryMessages);
    rawRetryLen = rawRetry.trim().length;
    const { text: retryText, truncated: retryTruncated } = sanitizeDescription(rawRetry);

    // Accept the retry only when format, length (sanitized), ZITADEL count, and
    // comma count are all acceptable.
    // When the first was semantically bad, tolerate up to 5 chars outside range;
    // otherwise only accept if the retry is no further from range than the first.
    const retryOk = !looksBad(rawRetry) && !retryTruncated && zOkFor(retryText) && countCommas(retryText) <= 2;
    const firstWasBad = looksBad(rawFirst) || firstTruncated || !inRange(firstText.length) || !zOkFor(firstText);
    const acceptRetry = retryOk && (
      firstWasBad
        ? distFromRange(retryText.length) <= 5
        : distFromRange(retryText.length) <= distFromRange(firstText.length)
    );
    if (acceptRetry) {
      desc = retryText;
    } else {
      // Third "repair" attempt: feed the best sanitized candidate back and ask
      // the model to adjust length only.  This is a much easier task than
      // rewriting from scratch and helps when small models struggle to hit
      // 130–160 in one or two shots.
      const candidate = (retryOk ? retryText : firstText) || firstText;
      const repairMessages = [
        ...messages,
        { role: 'assistant', content: candidate },
        {
          role: 'user',
          content:
            `Adjust this to exactly 130–160 characters. Keep all technical terminology and meaning intact. ` +
            `Return ONLY the adjusted plain text — no quotes, no labels.\n\nMeta description:`,
        },
      ];
      const rawRepair = await callLLM(repairMessages);
      const { text: repairText, truncated: repairTruncated } = sanitizeDescription(rawRepair);
      if (!looksBad(rawRepair) && !repairTruncated && zOkFor(repairText) && countCommas(repairText) <= 2) {
        desc = repairText;
      }
      // If repair still fails, desc remains firstText (truncated last resort).
    }
  }

  return { description: desc, rawFirstLen: rawFirst.trim().length, rawRetryLen, retried };
}

/** Sleep helper. */
const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main() {
  console.log(`LLM endpoint : ${BASE_URL}`);
  console.log(`Model        : ${MODEL}`);
  console.log(`Dry run      : ${DRY_RUN}`);
  console.log(`Delay        : ${DELAY_MS}ms`);
  console.log(`Excluded     : reference/, v*/, apis/proto/, **/index.mdx\n`);

  // Build file list
  let files: string[];
  if (SINGLE_FILE) {
    const resolved = resolve(CONTENT_DIR, SINGLE_FILE);
    const rel = relative(CONTENT_DIR, resolved);
    if (rel.startsWith('..')) {
      console.error(`Error: --file path escapes the content directory: ${SINGLE_FILE}`);
      process.exit(1);
    }
    files = [resolved];
  } else {
    const all = await globMdx(CONTENT_DIR);
    files = all
      .filter((f) => {
        const rel = relative(CONTENT_DIR, f);
        // Skip partial files (filenames starting with _)
        if (basename(f).startsWith('_')) return false;
        // Skip generated/versioned directories
        if (isExcluded(rel)) return false;
        return true;
      });
    files.sort();
  }

  // Read each file once, parse frontmatter, and keep the data for the processing
  // loop — this avoids touching the disk twice and uses a sequential for...of loop
  // to prevent EMFILE (too many open files) errors on large repos.
  type EligibleFile = { path: string; relPath: string; content: string; fm: Record<string, string>; body: string };
  const eligible: EligibleFile[] = [];
  for (const f of files) {
    const content = await readFile(f, 'utf-8');
    const { fm, rawFm, body } = parseFrontmatter(content);
    // Use hasRealDescription() on the raw frontmatter rather than the flat-parsed
    // map — it correctly handles block scalars (description: >\n  ...) and empty
    // quoted strings that the simple parser misidentifies as present.
    if (!hasRealDescription(rawFm)) {
      eligible.push({ path: f, relPath: relative(CONTENT_DIR, f), content, fm, body });
    }
  }

  console.log(`Total non-generated MDX files : ${files.length}`);
  console.log(`Missing description           : ${eligible.length}`);
  if (START_FROM > 0) console.log(`Skipping first                : ${START_FROM}`);
  console.log('');

  const toProcess = eligible.slice(START_FROM, START_FROM + (isFinite(LIMIT) ? LIMIT : eligible.length));
  let succeeded = 0;
  let failed = 0;

  for (let i = 0; i < toProcess.length; i++) {
    const { path: filePath, relPath, content, fm, body } = toProcess[i];
    const globalIndex = START_FROM + i + 1;
    const progress = `[${globalIndex}/${eligible.length}]`;

    const title = fm['title'] ?? basename(filePath, '.mdx');
    // Strip imports/code-fences from the excerpt slice so that content-type
    // overrides ("Prerequisites" etc.) aren't hidden behind MDX components.
    const cleanedExcerpt = body.slice(0, 2000)
      .replace(/^import\s.*$/gm, '')
      .replace(/```[\s\S]*?```/g, '')
      .trim();
    const contentType = detectContentType(relPath, cleanedExcerpt);
    const context = extractContext(body, 900, contentType);

    process.stdout.write(`${progress} [${contentType}] ${relPath} … `);

    try {
      const { description, rawFirstLen, rawRetryLen, retried } = await generateDescription(title, context, contentType);
      const charCount = description.length;

      if (DRY_RUN) {
        const retryTag = retried
          ? ` retry=yes raw1=${rawFirstLen} rawR=${rawRetryLen}`
          : ` raw1=${rawFirstLen}`;
        console.log(`\n  → (dry-run) ${description} [${charCount} chars${retryTag}]`);
      } else {
        const updated = injectDescription(content, description);
        // Skip the write if nothing changed (e.g. LLM returned the existing value
        // on a re-run, or dry-run logic was accidentally inverted).
        if (updated !== content) writeFileSync(filePath, updated, 'utf-8');
        console.log(`done [${charCount} chars]`);
      }

      succeeded++;
    } catch (err) {
      console.log(`FAILED — ${(err as Error).message}`);
      failed++;
    }

    if (i < toProcess.length - 1) await sleep(DELAY_MS);
  }

  console.log(`\n✓ Succeeded: ${succeeded}  ✗ Failed: ${failed}`);
  if (failed > 0) process.exit(1);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
