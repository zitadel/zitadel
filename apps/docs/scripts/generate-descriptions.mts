/**
 * generate-descriptions.mts
 *
 * Generates SEO meta description frontmatter for MDX docs pages that are missing one,
 * using an OpenAI-compatible LLM endpoint (local or remote).
 *
 * Usage:
 *   node --experimental-strip-types apps/docs/scripts/generate-descriptions.mts [options]
 *
 * Options:
 *   --base-url <url>    LLM server base URL  (default: http://127.0.0.1:1234)
 *   --model <id>        Model identifier     (default: qwen2.5-14b-instruct)
 *   --dry-run           Preview without writing files
 *   --force             Re-generate even if a description already exists
 *   --file <path>       Process a single file only (relative to content/)
 *   --delay <ms>        Delay between API calls in ms (default: 200)
 *   --start-from <n>    Skip the first N eligible files (resume after interruption)
 *   --limit <n>         Process at most N files then stop
 *
 * Excluded content (generated / versioned — must not be edited):
 *   - content/reference/          auto-generated REST/gRPC API reference (generate-api-reference target)
 *   - content/v<N.M>/             versioned doc snapshots fetched at build time (fetch-remote-content target)
 *   - content/apis/proto/         buf-generated protobuf docs (gitignored)
 *   - any index.mdx              all index pages are generated by the generate-index-pages target
 *   - files starting with _       MDX partials (not navigable pages)
 */

import { writeFileSync } from 'node:fs';
import { readFile } from 'node:fs/promises';
import { relative, basename, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { parseArgs } from 'node:util';
import fg from 'fast-glob';

// ---------------------------------------------------------------------------
// Exclusion rules for generated / versioned / partial content.
// ---------------------------------------------------------------------------

/** Top-level directory names that are entirely auto-generated. */
const EXCLUDED_DIR_PREFIXES = [
  'reference', // generate-api-reference target → content/reference/api/
];

/** Top-level directory patterns that are auto-generated or fetched. */
const EXCLUDED_DIR_PATTERNS = [
  /^v\d/, // versioned snapshots: v4.10, v4.11, … (fetch-remote-content target)
];

/** Path prefixes (relative to content/) that are entirely auto-generated. */
const EXCLUDED_PATH_PREFIXES = [
  'apis/proto/', // buf-generated protobuf docs — gitignored, not committed
];

function isExcluded(contentRelPath: string): boolean {
  if (basename(contentRelPath) === 'index.mdx') return true;

  const first = contentRelPath.split('/')[0];
  if (EXCLUDED_DIR_PREFIXES.includes(first)) return true;
  if (EXCLUDED_DIR_PATTERNS.some((re) => re.test(first))) return true;
  if (EXCLUDED_PATH_PREFIXES.some((p) => contentRelPath.startsWith(p))) return true;

  return false;
}

// ---------------------------------------------------------------------------
// Content-category classification (4 broad categories)
// ---------------------------------------------------------------------------

type ContentCategory = 'reference' | 'guide' | 'concept' | 'other';

/** Map path prefixes to broad categories. Order matters — first match wins. */
const CATEGORY_RULES: Array<{ prefix: string; category: ContentCategory }> = [
  // Reference: API specs, protocol docs, benchmarks
  { prefix: 'apis/benchmarks/', category: 'reference' },
  { prefix: 'apis/actions/',    category: 'guide' },      // cookbook/how-to, not spec
  { prefix: 'apis/',            category: 'reference' },

  // Guide: how-tos, quickstarts, deployment, operations, SDK examples
  { prefix: 'guides/',          category: 'guide' },
  { prefix: 'sdk-examples/',    category: 'guide' },
  { prefix: 'examples/',        category: 'guide' },
  { prefix: 'self-hosting/',    category: 'guide' },

  // Concept: architecture, IAM model, product/roadmap
  { prefix: 'concepts/',        category: 'concept' },
  { prefix: 'product/',         category: 'concept' },

  // Other: legal, advisories, everything else
  { prefix: 'legal/',           category: 'other' },
  { prefix: 'support/advisory/', category: 'other' },
];

function detectCategory(relPath: string): ContentCategory {
  for (const { prefix, category } of CATEGORY_RULES) {
    if (relPath.startsWith(prefix)) return category;
  }
  return 'other';
}

/** Per-category prompt configuration. */
const CATEGORY_PROMPTS: Record<ContentCategory, { focusClause: string; pageKind: string }> = {
  reference: {
    pageKind: 'API or protocol reference page',
    focusClause:
      'Name the exact protocol, API, or benchmark scenario. ' +
      'For API reference pages, include the primary function or method names documented on the page (e.g., setClaim, setCustomAttribute). ' +
      'State what a developer can do with these endpoints or methods. ' +
      'Closely paraphrase the page\'s own introductory sentence for accuracy — do not reinterpret or generalize it.',
  },
  guide: {
    pageKind: 'how-to or integration guide',
    focusClause:
      'Identify the specific task or problem being solved. ' +
      'Name the exact tools, frameworks, or ZITADEL features involved. ' +
      'If a specific tech stack or platform is mentioned, include it. ' +
      'If the page is a collection of code examples, say so — include the words "code examples" in the description. ' +
      'Closely paraphrase the page\'s own introductory sentence for accuracy — do not reinterpret or generalize it.',
  },
  concept: {
    pageKind: 'conceptual or architectural documentation page',
    focusClause:
      'Open with the concept or feature name. ' +
      'Define what it is and why it matters within the ZITADEL IAM model. ' +
      'Use architectural or domain-specific terms from the content. ' +
      'Closely paraphrase the page\'s own introductory sentence for accuracy — do not reinterpret or generalize it.',
  },
  other: {
    pageKind: 'documentation page',
    focusClause:
      'Identify the main topic and state the key information this page provides. ' +
      'For legal documents, do not include "ZITADEL". ' +
      'For advisories, include the advisory ID and affected versions if present. ' +
      'Closely paraphrase the page\'s own introductory sentence for accuracy — do not reinterpret or generalize it.',
  },
};

// ---------------------------------------------------------------------------
// CLI argument parsing
// ---------------------------------------------------------------------------

const { values: _args } = parseArgs({
  args: process.argv.slice(2),
  options: {
    'base-url':   { type: 'string',  default: 'http://127.0.0.1:1234' },
    model:        { type: 'string',  default: 'Qwen2.5-72B-Instruct-GGUF' },
    'dry-run':    { type: 'boolean', default: false },
    force:        { type: 'boolean', default: false },
    file:         { type: 'string' },
    delay:        { type: 'string',  default: '200' },
    'start-from': { type: 'string',  default: '0' },
    limit:        { type: 'string' },
  },
});

const BASE_URL    = _args['base-url'] as string;
const MODEL       = _args.model as string;
const DRY_RUN     = _args['dry-run'] as boolean;
const FORCE       = _args['force'] as boolean;
const SINGLE_FILE = _args.file as string | undefined;
const DELAY_MS    = Number(_args.delay);
const START_FROM  = Number(_args['start-from']);
const LIMIT       = _args.limit !== undefined ? Number(_args.limit) : Infinity;

if (isNaN(DELAY_MS))   { console.error('Error: --delay must be a number'); process.exit(1); }
if (isNaN(START_FROM)) { console.error('Error: --start-from must be a number'); process.exit(1); }
if (_args.limit !== undefined && isNaN(LIMIT)) { console.error('Error: --limit must be a number'); process.exit(1); }

const CONTENT_DIR = fileURLToPath(new URL('../content', import.meta.url));

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Recursively collect all .mdx file paths under a directory. */
async function globMdx(dir: string): Promise<string[]> {
  return fg(['**/*.mdx'], { cwd: dir, absolute: true, dot: false, followSymbolicLinks: false });
}

/**
 * Parse YAML frontmatter from an MDX string.
 */
function parseFrontmatter(content: string): {
  fm: Record<string, string>;
  rawFm: string;
  body: string;
} {
  const { hasFm, fmRaw, body } = splitFrontmatter(content);
  if (!hasFm) return { fm: {}, rawFm: '', body: content };

  const fm: Record<string, string> = {};
  for (const line of fmRaw.split('\n')) {
    const kv = line.match(/^(\w[\w_-]*):\s*(.*)$/);
    if (kv) fm[kv[1]] = kv[2].trim().replace(/^["']|["']$/g, '');
  }

  return { fm, rawFm: fmRaw, body };
}

/**
 * Returns true when the raw frontmatter block contains a `description` key
 * with a non-empty, non-trivial value.
 */
function hasRealDescription(rawFm: string): boolean {
  const lines = rawFm.split('\n');
  const idx = lines.findIndex((l) => /^description:\s*/.test(l));
  if (idx === -1) return false;

  const first = lines[idx].replace(/^description:\s*/, '').trim();
  if (first && !/^[>|][+-]?$/.test(first) && !['""', "''"].includes(first)) return true;

  for (let i = idx + 1; i < lines.length; i++) {
    const l = lines[i];
    if (/^\S/.test(l)) break;
    if (l.trim().length > 0) return true;
  }

  return false;
}

/**
 * Build a rich context string for the LLM by sending up to ~8000 chars of page content.
 *
 * Strategy:
 *   1. Extract all ## / ### headings as a full document outline.
 *   2. Send cleaned body prose up to 8000 chars (imports and code fence bodies stripped,
 *      MDX component tags kept for structural signal).
 */
function extractContext(body: string): string {
  const maxBodyChars = 8000;

  // Strip imports and code fence bodies (keep first line as a signal)
  const cleaned = body
    .replace(/^import\s.*$/gm, '')
    .replace(/```(?:\w+)?\n([^\n]*)(?:[\s\S]*?)```/g, '[$1]')
    .replace(/```/g, '')
    .replace(/\n{3,}/g, '\n\n')
    .trim();

  // Build full heading outline
  const headings: string[] = [];
  for (const line of cleaned.split('\n')) {
    const m = line.match(/^\s*(#{2,3})\s+(.+?)\s*$/);
    if (m) {
      const indent = m[1].length === 3 ? '  -' : '-';
      headings.push(`${indent} ${m[2]}`);
    }
  }
  const outline =
    headings.length > 0
      ? `[DOCUMENT OUTLINE]\n${headings.join('\n')}\n\n`
      : '';

  // Send prose up to the budget — simple top-slice
  let prose = cleaned.slice(0, maxBodyChars).trim();
  if (cleaned.length > maxBodyChars) {
    // Cut at last word boundary to avoid mid-word truncation
    const lastSpace = prose.lastIndexOf(' ');
    if (lastSpace > maxBodyChars * 0.8) prose = prose.slice(0, lastSpace);
    prose += '\n[…truncated]';
  }

  let result = outline;
  if (prose) result += `[PAGE CONTENT]\n${prose}`;
  return result.trim();
}

/**
 * Sanitize LLM output: strip formatting artifacts, normalize casing, enforce length cap.
 */
function sanitizeDescription(text: string): string {
  let clean = text.trim();

  // Strip surrounding quotes
  clean = clean.replace(/^["']|["']$/g, '').trim();

  // Strip rogue markdown (bold, italic, inline code)
  clean = clean.replace(/[*`_]/g, '');

  // Strip banned openers the model sometimes ignores
  clean = clean.replace(/^(Explore|Discover|Learn( how( to)?)?|This (page|guide|document|article)|ZITADEL (guides|helps|shows|describes|walks)( you| developers?)?( through| how)?)[:\s,]+/i, '').trim();
  // Re-capitalize first letter after stripping
  if (clean.length > 0) clean = clean[0].toUpperCase() + clean.slice(1);

  // Collapse newlines and whitespace runs
  clean = clean.replace(/\r?\n+/g, ' ').replace(/\s{2,}/g, ' ').trim();

  // Extract first sentence only (cut at ". " / "? " / "! " boundary)
  const sentEnd = clean.search(/[.?!]\s/);
  if (sentEnd !== -1) clean = clean.slice(0, sentEnd).trim();

  // Strip leading/trailing dashes, em-dashes, colons
  clean = clean.replace(/^[\s\-–—:]+/, '').replace(/[\s\-–—:]+$/, '').trim();

  // Remove trailing period
  clean = clean.replace(/\.$/, '');

  // Normalize ZITADEL casing
  clean = clean.replace(/\bzitadel\b/gi, 'ZITADEL');

  // Hard cap at 160 chars, cut at last whole word
  if (clean.length > 160) {
    const cut = clean.slice(0, 160);
    const lastSpace = cut.lastIndexOf(' ');
    clean = lastSpace > 40 ? cut.slice(0, lastSpace) : cut.trim();
    // Strip trailing punctuation after truncation
    clean = clean.replace(/[.!?:,\-–—]+$/, '').trim();
  }

  // Detect dangling fragments left after truncation (e.g. "functions like", "in the SAML")
  // If the description ends with a preposition, conjunction, article, or dangling word, trim it.
  const danglingPattern = /\s+(like|using|with|for|in|on|at|to|of|the|a|an|and|or|by|from|into|through|via|such|as|including|between|across|within|about|during|over)$/i;
  while (danglingPattern.test(clean)) {
    clean = clean.replace(danglingPattern, '').trim();
    clean = clean.replace(/[.!?:,\-–—]+$/, '').trim();
  }

  return clean;
}

/**
 * Slice content into its raw frontmatter and body parts.
 */
function splitFrontmatter(content: string): { hasFm: boolean; fmRaw: string; body: string } {
  const m = content.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n?([\s\S]*)$/);
  if (!m) return { hasFm: false, fmRaw: '', body: content };
  return { hasFm: true, fmRaw: m[1], body: m[2] ?? '' };
}

/**
 * Inject or replace the `description` field inside the frontmatter block only.
 */
function injectDescription(content: string, description: string): string {
  const escaped = description.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  const { hasFm, fmRaw, body } = splitFrontmatter(content);

  const eol = content.includes('\r\n') ? '\r\n' : '\n';
  const lines = hasFm ? fmRaw.split('\n').map((l) => l.replace(/\r$/, '')) : [];

  const descIdx = lines.findIndex((l) => /^description:\s*/.test(l));
  if (descIdx !== -1) {
    // Replace existing — also remove any continuation lines (block scalar)
    lines[descIdx] = `description: "${escaped}"`;
    while (descIdx + 1 < lines.length && /^\s/.test(lines[descIdx + 1])) {
      lines.splice(descIdx + 1, 1);
    }
  } else {
    const titleIdx = lines.findIndex((l) => /^title:\s*/.test(l));
    if (titleIdx !== -1) {
      lines.splice(titleIdx + 1, 0, `description: "${escaped}"`);
    } else {
      lines.unshift(`description: "${escaped}"`);
    }
  }

  const fmBlock = `---${eol}${lines.join(eol)}${eol}---${eol}`;
  return hasFm ? fmBlock + body : fmBlock + content;
}

/**
 * Perform a chat completion call. Retries up to 3 times on network-level failures.
 */
async function callLLM(
  messages: Array<{ role: string; content: string }>,
  maxTokens = 200,
): Promise<string> {
  const MAX_ATTEMPTS = 3;
  let lastError: Error | undefined;

  for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 60_000);
      let response: Response;
      try {
        response = await fetch(`${BASE_URL}/v1/chat/completions`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            model: MODEL,
            messages,
            max_tokens: maxTokens,
            temperature: 0.3,
            top_p: 0.9,
            stop: ['\n\n'],
          }),
          signal: controller.signal,
        });
      } finally {
        clearTimeout(timeoutId);
      }

      if (!response.ok) {
        const text = await response.text();
        if (response.status < 500) throw new Error(`LLM API error ${response.status}: ${text}`);
        throw new Error(`LLM server error ${response.status}: ${text}`);
      }

      const json = (await response.json()) as {
        choices: Array<{ message: { content: string } }>;
      };
      return json.choices?.[0]?.message?.content ?? '';
    } catch (err) {
      lastError = err as Error;
      if (attempt < MAX_ATTEMPTS) {
        const backoffMs = 500 * 2 ** (attempt - 1);
        await new Promise((r) => setTimeout(r, backoffMs));
      }
    }
  }

  throw lastError;
}

/**
 * Extract ## headings from body text (not ### or deeper).
 * Used to surface the major page sections explicitly in the user prompt.
 */
function extractMajorSections(body: string): string[] {
  const headings: string[] = [];
  for (const line of body.split('\n')) {
    const m = line.match(/^\s*##\s+(.+?)\s*$/);
    // Only match ## (not ### or deeper)
    if (m && !line.match(/^\s*###/)) headings.push(m[1]);
  }
  return headings;
}

/**
 * Extract API method / function names from body text.
 * Looks for patterns like `methodName(` or `api.v1.something.methodName(`.
 * Returns deduplicated list of short method names.
 */
function extractMethodNames(body: string): string[] {
  const methods = new Set<string>();
  // Match patterns like setClaim(, setCustomAttribute(, getMetadata(, appendLogIntoClaims(
  const re = /\b([a-z][a-zA-Z]+)\s*\(/g;
  let match: RegExpExecArray | null;
  while ((match = re.exec(body)) !== null) {
    const name = match[1];
    // Filter out common noise words and JS builtins
    if (name.length >= 4 && !['function', 'import', 'require', 'return', 'export', 'const', 'console', 'props', 'details', 'summary'].includes(name)) {
      methods.add(name);
    }
  }
  return [...methods];
}

/**
 * Generate a meta description for a single page.
 * One LLM call — no retries for content quality.
 */
async function generateDescription(
  title: string,
  context: string,
  category: ContentCategory,
  body: string,
): Promise<string> {
  const { focusClause, pageKind } = CATEGORY_PROMPTS[category];

  const isLegal = category === 'other' && /\blegal\b/i.test(title);
  const brandRule = isLegal
    ? 'Do not include "ZITADEL" in the description.'
    : 'Include "ZITADEL" exactly once.';

  // Extract top-level sections to surface them explicitly in the prompt.
  const majorSections = extractMajorSections(body);
  let breadthRule = '';
  if (majorSections.length >= 2) {
    breadthRule =
      `CRITICAL: This page covers ${majorSections.length} major topics: ${majorSections.join(', ')}. ` +
      'Your description MUST reflect this breadth — do NOT focus only on the first topic. ' +
      'Mention at least 2–3 of these topics in a single flowing sentence.\n';
  }

  const systemPrompt =
    'You write SEO meta descriptions for ZITADEL technical documentation.\n' +
    'Output ONLY the description text — no labels, no quotes, no markdown.\n' +
    '\n' +
    '## FORMAT RULES\n' +
    'Exactly ONE sentence, plain text, 100–150 characters. Never exceed 155.\n' +
    `${brandRule}\n` +
    '\n' +
    '## SENTENCE STRUCTURE\n' +
    'Start with a concrete noun, feature name, or action verb from the page — NEVER with filler openers.\n' +
    'BANNED first words: "Explore", "Discover", "Learn", "This page", "This guide", "ZITADEL guides", "ZITADEL helps", "ZITADEL shows", "ZITADEL describes".\n' +
    'End with a concrete noun or specific outcome — NEVER with vague words like "management", "workflows", "and more", "solutions", or "tasks".\n' +
    '\n' +
    '## GOOD EXAMPLES (imitate these patterns)\n' +
    '- "Configure ZITADEL session tokens with custom lifetime, metadata, and multi-factor requirements"\n' +
    '- "ZITADEL Personal Access Tokens let you authenticate service users for API calls without interactive login"\n' +
    '- "Mirror events between ZITADEL instances using the cockroach and postgres export commands"\n' +
    '\n' +
    '## BAD EXAMPLES (never produce these)\n' +
    '- "Explore ZITADEL features for managing authentication" ← starts with Explore, too vague\n' +
    '- "ZITADEL guides you through configuring session parameters" ← starts with ZITADEL guides\n' +
    '- "Learn how to customize attributes before they are set in the" ← truncated, starts with Learn how\n' +
    '\n' +
    '## ACCURACY RULES\n' +
    'Closely paraphrase the page\'s own introductory sentence — do not reinterpret or generalize it.\n' +
    'Use only terms, method names, and facts that appear in the page content.\n' +
    'Do NOT reference internal API IDs, flow IDs, or trigger IDs — write for search engine users, not API consumers.\n' +
    'Do NOT invent versions, feature names, or specs not present in the content.\n' +
    `${breadthRule}` +
    '\n' +
    focusClause;

  // Surface API method names explicitly so the model can include them.
  const methodNames = extractMethodNames(body);
  let methodHint = '';
  if (methodNames.length > 0) {
    methodHint = `\n[KEY METHODS on this page]: ${methodNames.join(', ')}\n`;
  }

  const userPrompt =
    `Page kind: ${pageKind}\n` +
    `Title: ${title}\n` +
    `${methodHint}\n` +
    `${context}`;

  const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt },
  ];

  const raw = await callLLM(messages);
  return sanitizeDescription(raw);
}

/** Sleep helper. */
const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------

async function main() {
  console.log(`LLM endpoint : ${BASE_URL}`);
  console.log(`Model        : ${MODEL}`);
  console.log(`Dry run      : ${DRY_RUN}`);
  console.log(`Force        : ${FORCE}`);
  console.log(`Delay        : ${DELAY_MS}ms`);
  console.log(`Excluded     : reference/, v*/, apis/proto/, **/index.mdx\n`);

  // Build file list
  let files: string[];
  if (SINGLE_FILE) {
    const resolved = resolve(CONTENT_DIR, SINGLE_FILE);
    const rel = relative(CONTENT_DIR, resolved);
    if (rel.startsWith('..')) {
      console.error(`Error: --file path escapes the content directory: ${SINGLE_FILE}`);
      process.exit(1);
    }
    files = [resolved];
  } else {
    const all = await globMdx(CONTENT_DIR);
    files = all.filter((f) => {
      const rel = relative(CONTENT_DIR, f);
      if (basename(f).startsWith('_')) return false;
      if (isExcluded(rel)) return false;
      return true;
    });
    files.sort();
  }

  // Read and filter eligible files
  type EligibleFile = { path: string; relPath: string; content: string; fm: Record<string, string>; body: string };
  const eligible: EligibleFile[] = [];
  for (const f of files) {
    const content = await readFile(f, 'utf-8');
    const { fm, rawFm, body } = parseFrontmatter(content);
    if (FORCE || !hasRealDescription(rawFm)) {
      eligible.push({ path: f, relPath: relative(CONTENT_DIR, f), content, fm, body });
    }
  }

  console.log(`Total non-generated MDX files : ${files.length}`);
  console.log(`Missing description           : ${eligible.length}`);
  if (START_FROM > 0) console.log(`Skipping first                : ${START_FROM}`);
  console.log('');

  const toProcess = eligible.slice(START_FROM, START_FROM + (isFinite(LIMIT) ? LIMIT : eligible.length));
  let succeeded = 0;
  let failed = 0;

  for (let i = 0; i < toProcess.length; i++) {
    const { path: filePath, relPath, content, fm, body } = toProcess[i];
    const globalIndex = START_FROM + i + 1;
    const progress = `[${globalIndex}/${eligible.length}]`;

    const title = fm['title'] ?? basename(filePath, '.mdx');
    const category = detectCategory(relPath);
    const context = extractContext(body);

    process.stdout.write(`${progress} [${category}] ${relPath} … `);

    try {
      const description = await generateDescription(title, context, category, body);
      const charCount = description.length;

      if (charCount < 20) {
        console.log(`SKIPPED — description too short (${charCount} chars)`);
        failed++;
        continue;
      }

      if (DRY_RUN) {
        console.log(`\n  → (dry-run) ${description} [${charCount} chars]`);
      } else {
        const updated = injectDescription(content, description);
        if (updated !== content) writeFileSync(filePath, updated, 'utf-8');
        console.log(`done [${charCount} chars]`);
      }

      succeeded++;
    } catch (err) {
      console.log(`FAILED — ${(err as Error).message}`);
      failed++;
    }

    if (i < toProcess.length - 1) await sleep(DELAY_MS);
  }

  console.log(`\n✓ Succeeded: ${succeeded}  ✗ Failed: ${failed}`);
  if (failed > 0) process.exit(1);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
