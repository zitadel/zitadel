---
title: Set up ZITADEL with Docker Compose
sidebar_label: Docker Compose
description: Deploy ZITADEL with Docker Compose — from a 2-minute localhost quickstart to a hardened homelab setup with TLS, caching, and observability.
---

import { Callout } from 'fumadocs-ui/components/callout';
import NoteInstanceNotFound from './troubleshooting/_note_instance_not_found.mdx';
import Disclaimer from './_disclaimer.mdx'
import DefaultUser from './_defaultuser.mdx'
import Next from './_next.mdx'

This guide takes you from zero to a running ZITADEL instance in minutes and then shows you how to harden it for a homelab or semi-production deployment.

## Prerequisites

- Docker Engine 24+ with the Compose plugin (`docker compose`)
- `curl` (for the quickstart download)
- A machine with at least 2 GB RAM

## Stage 1 — Quickstart (2 minutes)

Download the deployment pack, copy the example config, and start:

```shell
# Download the compose pack from the main branch.
# The tar prefix (zitadel-main/) matches the branch name in the URL.
curl -L https://github.com/zitadel/zitadel/archive/refs/heads/main.tar.gz \
  | tar xz --strip-components=2 zitadel-main/deploy/compose
cd compose

# Create your environment file and start
cp .env.example .env
docker compose up -d --wait
```

That's it. Visit [http://localhost:8080](http://localhost:8080) to open the login screen.

<DefaultUser components={props.components} />

<Callout type="info">
The base stack runs: **Traefik** (reverse proxy) → **ZITADEL API** (Go) + **ZITADEL Login** (Next.js) → **PostgreSQL**.
All routing, including gRPC, is handled automatically by Traefik — no extra configuration needed.
</Callout>

## Stage 2 — Homelab / Semi-Production

### Use your own domain

Edit `.env` and set your real domain:

```dotenv
ZITADEL_DOMAIN=auth.example.com
```

### Enable TLS with Let's Encrypt

The easiest path for a homelab with a public domain:

```shell
docker compose --env-file .env \
  -f docker-compose.yml \
  -f docker-compose.mode-letsencrypt.yml \
  up -d --wait
```

Set `LETSENCRYPT_EMAIL` in `.env` to receive certificate expiry notifications.

Other TLS options:

| Mode | Overlay file | When to use |
|------|-------------|-------------|
| Let's Encrypt | `docker-compose.mode-letsencrypt.yml` | Public domain, automatic certs |
| External TLS | `docker-compose.mode-external-tls.yml` | Behind a load balancer, CDN, or WAF that terminates TLS |
| Local TLS | `docker-compose.mode-local-tls.yml` | Self-signed certs for LAN-only access |

### Harden secrets

```shell
# Generate a secure masterkey (must be exactly 32 characters)
ZITADEL_MASTERKEY=$(tr -dc A-Za-z0-9 </dev/urandom | head -c 32)
echo "ZITADEL_MASTERKEY=$ZITADEL_MASTERKEY" >> .env

# Set strong database passwords
echo "POSTGRES_ADMIN_PASSWORD=$(tr -dc A-Za-z0-9 </dev/urandom | head -c 32)" >> .env
echo "POSTGRES_ZITADEL_PASSWORD=$(tr -dc A-Za-z0-9 </dev/urandom | head -c 32)" >> .env
```

### Understanding ExternalDomain, ExternalPort, ExternalSecure

These three settings **must match your public endpoint exactly**:

| Setting | Meaning | Example |
|---------|---------|---------|
| `ZITADEL_DOMAIN` | The public domain users type in | `auth.example.com` |
| `ZITADEL_EXTERNALPORT` | The port visible to users | `443` for HTTPS |
| `ZITADEL_EXTERNALSECURE` | Whether the public URL uses HTTPS | `true` for any TLS mode |

If these don't match reality, ZITADEL returns **"Instance not found"** errors. This is the most common deployment issue — see the [troubleshooting guide](/self-hosting/manage/tls_modes) for details.

<NoteInstanceNotFound />

### Enable caching with Redis

```shell
docker compose --env-file .env -f docker-compose.yml --profile cache up -d --wait
```

Then set in `.env`:

```dotenv
ZITADEL_CACHES_CONNECTORS_REDIS_ENABLED=true
ZITADEL_CACHES_INSTANCE_CONNECTOR=redis
ZITADEL_CACHES_MILESTONES_CONNECTOR=redis
ZITADEL_CACHES_ORGANIZATION_CONNECTOR=redis
```

## Stage 3 — Beyond Compose

### Production-like init/setup/start split

For controlled upgrades, separate database initialization from the running API:

```shell
docker compose --env-file .env \
  -f docker-compose.yml \
  -f docker-compose.prodlike.yml \
  up -d --wait
```

This creates three ZITADEL containers:
1. `zitadel-init` — runs database migrations (one-shot)
2. `zitadel-setup` — configures the instance (one-shot)
3. `zitadel-api` — starts the API server (long-running)

### Enable observability

```shell
docker compose --env-file .env -f docker-compose.yml --profile observability up -d --wait
```

Set in `.env`:

```dotenv
ZITADEL_INSTRUMENTATION_TRACE_EXPORTER_TYPE=grpc
```

Jaeger UI is available at `http://localhost:16686`.

### Scale API replicas

```shell
docker compose --env-file .env -f docker-compose.yml up -d --scale zitadel-api=3
```

### Updating ZITADEL

Edit `ZITADEL_VERSION` in `.env`, then:

```shell
docker compose --env-file .env -f docker-compose.yml pull
docker compose --env-file .env -f docker-compose.yml up -d --wait
```

<Callout>
`ZITADEL_FIRSTINSTANCE_*` and `ZITADEL_DEFAULTINSTANCE_*` environment variables are only applied during the **initial setup**.
To change settings on an existing installation, use the Admin Console or Admin API.
</Callout>

### Moving to Kubernetes

Docker Compose is ideal for getting started and homelab deployments.
For production workloads, ZITADEL provides an official [Helm chart for Kubernetes](/self-hosting/deploy/kubernetes).

The compose pack and the Helm chart share the same application configuration model (`ZITADEL_*` environment variables), so migration is straightforward.

<Next components={props.components} />
